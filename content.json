[{"title":"tset","date":"2018-05-18T03:51:06.000Z","path":"2018/05/18/tset.html","text":"我就是想测试下，访问数量统计是否正常","tags":[]},{"title":"电影：爆裂鼓手","date":"2018-05-17T17:21:26.000Z","path":"2018/05/18/电影：爆裂鼓手.html","text":"http://www.le.com/ptv/vplay/29937749.html#vid=29937749 20180518：凌晨01:04分 刚看完爆裂鼓手，看完最后一段后，我知道，又一个查理·帕克诞生了，从魔鬼导师的眼里能看出来。 此时的我眼里少许热泪，想到了自己人生里是否也能出现一位这样的魔鬼导师？压迫到自己喘不过气来。 魔鬼导师在与安德鲁对话中，导师说道一句话让我特别感触，他说：“我是去逼他们突破自己的极限的”。这句话特别触动了我。 我现在24周岁，非常希望在30岁之前能遇到我的魔鬼导师，能逼迫我挑战自己的极限。 在我成长的同时，我也需要学习魔鬼导师的精神，去找到属于我的查理·帕克！ 这个片子值得我过几年后再次看看，那时候我应该是热泪盈眶，到那时希望溜的不是泪水，而是故事。 同样适合我被上司，公司等对我严厉，严格的人事物们，特别是有种上班入上坟的感觉时，最应该看看这个片子，我应该会想通，过几年后我拿着高薪，生活过得美满时，应该感谢的人是谁！","tags":[{"name":"电影","slug":"电影","permalink":"//nicksors.cc/tags/电影/"}]},{"title":"Kubernetes是什么？","date":"2018-05-17T04:08:29.000Z","path":"2018/05/17/Kubernetes是什么？.html","text":"这是一篇从零开始了解Kubernetes的理论文章，从概念介绍到其关键技术再到架构设计，都能帮助我能更好的理解Kubernetes。 一、Kubernetes简介 Kubernetes是Google在2014年6月开园的一个容器集群管理系统，该系统使用Google研发的Golang语言开发。Kubernetes也被叫做k8s，因为k和s之前有8个字母。 k8s原本是Google内部一个叫Borg的容器集群管理系统衍生出来的，Borg已经在Google大规模生产运行十年之久。 k8s主要用于自动化部署、扩展和管理容器应用，它提供了资源调度、部署管理、服务发现、扩容缩容、监控等一整套功能。 Kubernetes的目标是让部署容器化应用简单高效。官网地址：https://www.kubernetes.io 二、Kubernetes主要功能2.1、数据卷在Pod中，容器之前共享数据，可以使用数据卷。这个功能与docker里volume功能相等。 2.2、应用程序健康检查检查容器内的服务、进程是否异常；可以设置监控检测策略来保证应用的健壮性。 2.3、复制应用程序实例控制维护Pod副本数，保证一个Pod或一组同类的Pod数始终可用。 2.4、弹性缩容根据设定的指标（CPU利用率）自动缩放Pod副本数。 2.5、服务发现使用环境变量或DOS服务插件保证容器中程序发现Pod入口访问地址。 2.6、负载均衡一组Pod副本分配一个私有的集群IP地址，负载均衡转发请求到后端容器。在集群内部，其他Pod可通过这个ClusterIP访问应用。 2.7、滚动更新更新服务不中断，异常更新一个Pod，而不是同时删除整个服务。 2.8、服务编排通过文件描述部署服务，使得应用程序部署变得更高效。 2.9、资源监控Node节点组件继承CAdvisor资源收集工具，可通过Heapster汇总整个集群节点资源数据，然后存储到InfluxDB时序数据库中，再由Grafana展示。 2.10、提供认证和授权支持角色访问控制（RBAC）认证授权等策略。 三、基本概念 在k8s中，它的概念非常的多！而且一定要去了解这些概念，知道它的作用是必须的，你需要知道这些概念，才能更好的应用它。 3.1、PodPod是k8s最小部署单元，一个Pod有一个或多个容器组成，Pod中容器共享存储和网络，在同一个Docker主机上运行。官网解读：https://www.kubernetes.org.cn/kubernetes-pod 3.2、ServiceService一个应用服务的抽象，定义了Pod逻辑集合和访问这个Pod集合的策略。官网解读：https://www.kubernetes.org.cn/kubernetes-services 3.3、Volume数据卷，共享Pod中容器使用的数据。官网解读：https://www.kubernetes.org.cn/kubernetes-volumes 3.4、Namespace命名空间将对象逻辑上分配到不同Namespace，可以是不同的项目、用户等分区管理，并设定控制策略，从而实现多租户。官网解读：https://www.kubernetes.org.cn/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%EF%BC%9Anamespace 3.5、Lable标签用于区分对象（比如Pod、Service），键/值对存在；每个对象可以有多个标签，通过标签关联对象。官网解读：https://www.kubernetes.org.cn/kubernetes-labels 四、更高层次的抽象4.1、ReplicaSet（RS）ReplicaSet是下一代复本控制器。官网解读：https://www.kubernetes.org.cn/replicasets 4.2、DeploymentDeployment是一个更高层次的API对象，它管理ReplicaSets和Pod，并提供声明式更新等功能。官方建议使用Department管理ReplicaSets,而不是直接使用ReplicaSets，这就意味着可能永远不需要直接操作ReplicaSet对象。 咱们在实际应用当中，基本上都是去创建一个Deployment，然后由Deployment去创建RS和Pod等。官网解读：https://www.kubernetes.org.cn/deployment 4.3、StatefulSetStatefulSet适合持久性的应用程序，有唯一的网络标识符（IP），持久存储，有序的部署、扩展、删除和滚动更新。官网解读：https://www.kubernetes.org.cn/statefulset 4.4、DaemonSetDaemonSet确保所有（或一些）节点运行同一个Pod。当节点加入Kubernetes集群中，Pod会被调度到该节点上运行，当节点从集群中移除时，DaemonSet的Pod会被删除。删除DaemonSet会清理它所有创建的Pod。官网解读：https://www.kubernetes.org.cn/daemonset 4.5、Job一次性任务，运行完成后Pod销毁，不在重新启动新容器。还可以任务定时运行。官网解读：https://www.kubernetes.org.cn/job 五、Kubernetes系统架构拓扑图 六、组件功能介绍6.1、Master组件 kube-apiserverKubernetes API，集群的统一入口，各组件协调者。以HTTP API提供接口服务，所有对象的增删改查和监听操作都交给API Server处理后再提交给Etcd存储。 kube-controller-master处理集群中常规后台任务，一个资源对应一个控制器，而ControllerManager就是负责管理这些控制器的。 kube-scheduler根据调度算法为新创建的Pod选择一个Node节点。 6.2、Node组件 kubeletkubelet是Master在Node节点上的Agent，管理本机运行容器的生命周期，比如创建容器、Pod挂载数据卷、下载secret、获取容器和节点状态等工作。kubelet将每个Pod转换成一组容器。 kube-proxy在Node节点上实现Pod网络代理，维护网络规则和四层负载均衡工作。 docker或rocket/rktk8s可选的容器运行底层支持技术，一般我们都使用docker。 6.3、第三方服务 etcd分布式键值存储系统。用于保持集群状态，比如Pod、Service等对象信息。 本文完.","tags":[]},{"title":"使用Docker构建持续集成环境","date":"2018-05-16T06:02:21.000Z","path":"2018/05/16/使用Docker构建持续集成环境.html","text":"前言：本文将使用Docker+Git+Maven+Jenkins构建一套持续集成环境，可上线生产，本文内容请酌情参考. 0、服务器部署规划 服务名称 主机名 IP 开发机客户端 k8s-mster 1 72.16.194.128 测试服务器（Docker）、Jenkins服务器 k8s-node01 172.16.194.129 Git/Docker registry k8s-node02 172.16.194.130 ———-我是分割线——— 工具 版本 CentOS 7.2_x64 Maven 3.5 Tomcat 8 JDK 1.8 Jenkins 2.6 Docker CE 18.03 1、CI/CD 2、发布流程设计 3、部署Git服务器1.安装git1[root@k8s-node02 ~]# yum install git -y 2.创建用户12useradd gitpasswd git 3.创建仓库123su - gitmkdir app.gitgit --bare init app.git 4.克隆仓库在另外的节点上操作1234567891011121314[root@k8s-master ~]# yum install git -y[root@k8s-master ~]# git clone git@172.16.194.130:/home/git/app.git正克隆到 'app'...The authenticity of host '172.16.194.130 (172.16.194.130)' can't be established.ECDSA key fingerprint is 60:eb:ee:4d:7d:12:10:5d:49:0c:7a:f3:81:5d:1f:2b.Are you sure you want to continue connecting (yes/no)? yssWarning: Permanently added '172.16.194.130' (ECDSA) to the list of known hosts.git@172.16.194.130's password:warning: 您似乎克隆了一个空版本库。[root@k8s-master ~]# cd app/[root@k8s-master app]# ls -lh总用量 0[root@k8s-master app]# 5.生成秘钥对，配置免密clone12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[root@k8s-master ~]# ssh-keygenGenerating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:5a:f9:66:7a:53:5a:2c:f9:a4:bc:98:5e:29:7d:2d:6f root@k8s-masterThe key's randomart image is:+--[ RSA 2048]----+| || || || . || S o || o oo.=. || . ..BOo . || O*..oE || .=..o .. |+-----------------+[root@k8s-master ~]# ls -lh /root/.ssh/总用量 12K-rw------- 1 root root 1.7K 3月 29 18:46 id_rsa-rw-r--r-- 1 root root 397 3月 29 18:46 id_rsa.pub-rw-r--r-- 1 root root 176 3月 29 17:57 known_hosts[root@k8s-master ~]# ssh-copy-id git@172.16.194.130 /usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keysgit@172.16.194.130's password:Number of key(s) added: 1Now try logging into the machine, with: \"ssh 'git@172.16.194.130'\"and check to make sure that only the key(s) you wanted were added.[root@k8s-master ~]## 查看master节点cp过来的秘钥[root@k8s-node02 ~]# su - git上一次登录：四 3月 29 17:52:09 CST 2018pts/1 上[git@k8s-node02 ~]$ ls -lh .ssh/authorized_keys-rw-------. 1 git git 397 Mar 29 18:49 .ssh/authorized_keys[git@k8s-node02 ~]$ cat !$cat .ssh/authorized_keysssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDHp/RZmgz5R5Nw1pQXyPjVynDu0kkn/3i05WR7CRNS31ylGkkI5k7AOmw8sEEDn3mAQg/z/xEI+LIoCRu68MESJEkqXX2oHzsEa6/JB6X3OW4VIwAkwD8W1FUppK1dueAmnZmx4k7ZiIgE43QWxcOuDthQ2mO3ybWjk13tR0viz4mrcuK/ulkW5AOlLP1I2A4NkTVmkXktk/CuTrULph/VXz10kbX+u0OPNxDLGzUdC94Issm4IPZRwYBhgYviCNEIxZW2pBrpnL3rXmVHHE4eeNGNJ0DnhaX32p4wYAKqujU1VK7udED2Af9rYgE9yArRfTc53di6OXTrlJ7polG/ root@k8s-master# 删除app项目后，重新clone就不需要密码了[root@k8s-master ~]# git clone git@172.16.194.130:/home/git/app.git正克隆到 'app'...warning: 您似乎克隆了一个空版本库。 6.克隆博客系统，提交到自建git仓库1.git clone tale1[root@k8s-master ~]# git clone https://github.com/otale/tale.git 2.提交到我们自己的git仓库里12345678910111213141516171819202122232425262728293031323334353637383940414243444546[root@k8s-master ~]# \\cp -a tale/* app/[root@k8s-master ~]# ls -lh app/总用量 24Kdrwxr-xr-x 2 root root 21 3月 29 18:45 bin-rw-r--r-- 1 root root 1.1K 3月 29 18:45 LICENSE-rw-r--r-- 1 root root 1.5K 3月 29 18:45 package.xml-rw-r--r-- 1 root root 7.1K 3月 29 18:45 pom.xmlf-rw-r--r-- 1 root root 2.8K 3月 29 18:45 README.md-rw-r--r-- 1 root root 2.7K 3月 29 18:45 README_ZH.mddrwxr-xr-x 3 root root 17 3月 29 18:45 src[root@k8s-master app]# git add .[root@k8s-master app]# git status[root@k8s-master app]# git config --global user.email \"you@example.com\" # 这两步需要执行下，内容随便，不然commit时会提示[root@k8s-master app]# git config --global user.name \"Your Name\"[root@k8s-master app]# git commit -m 'all'[root@k8s-master app]# git pushwarning: push.default 未设置，它的默认值将会在 Git 2.0 由 'matching'修改为 'simple'。若要不再显示本信息并在其默认值改变后维持当前使用习惯，进行如下设置： git config --global push.default matching若要不再显示本信息并从现在开始采用新的使用习惯，设置： git config --global push.default simple参见 'git help config' 并查找 'push.default' 以获取更多信息。（'simple' 模式由 Git 1.7.11 版本引入。如果您有时要使用老版本的 Git，为保持兼容，请用 'current' 代替 'simple' 模式）No refs in common and none specified; doing nothing.Perhaps you should specify a branch such as 'master'.fatal: The remote end hung up unexpectedlyerror: 无法推送一些引用到 'git@172.16.194.130:/home/git/app.git'[root@k8s-master app]# git push origin master # 需要提交到origin master 主干仓库Counting objects: 297, done.Delta compression using up to 4 threads.Compressing objects: 100% (255/255), done.Writing objects: 100% (297/297), 6.35 MiB | 0 bytes/s, done.Total 297 (delta 22), reused 0 (delta 0)To git@172.16.194.130:/home/git/app.git* [new branch] master -&gt; master 4、Docker私有镜像仓库搭建1.创建私有仓库容器123# 在node2上运行仓库容器[root@k8s-node02 ~]# docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 --restart=always --name registry registryb45a684be68fbecebe6c433e38eb98ca805fe3b45e44594057cbb3c5bf99bb13 2.构建tale开源博客基础镜像12345678910111213141516171819202122232425262728293031mkdir tale &amp;&amp; cd talecat &gt; Dockerfile&lt;&lt;EOFFROM centos:7RUN yum install epel-release -yRUN yum install nginx supervisor -y &amp;&amp; yum clean allRUN sed -i '47a proxy_pass http://127.0.0.1:9000;' /etc/nginx/nginx.confCOPY supervisord.conf /etc/supervisord.confENV PATH /usr/local/jdk/bin/:$PATHWORKDIR /taleCMD [\"/usr/bin/supervisord\"]EOFcat &gt;supervisord.conf&lt;&lt;EOF[supervisord]nodaemon=true[program:tale]command=/usr/local/jdk/bin/java -jar /tale/tale-least.jarautostart=trueautorestart=true[program:nginx]command=/usr/sbin/nginx -g \"daemon off;\"autostart=trueautorestart=trueEOF[root@k8s-node02 tale]# docker build -t tale:v1 .[root@k8s-node02 tale]# docker images|grep taletale v1 cd96b2fd2d6b 41 seconds ago 372MB 3.提交tale基础镜像到私有仓库123456# 这一步尤为重要，因为后面Jenkins会来拉取这个镜像进行应用部署docker tag tale:v1 172.16.194.130:5000/tale:v1docker push 172.16.194.130:5000/tale:v1# 查看提交的镜像版本信息curl http://172.16.194.130:5000/v2/tale/tags/list 5、测试服务器安装Docker1.安装docker123456789yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repoyum install docker-ce 2.配置官方国内镜像源、添加私有仓库可信任12345678[root@k8s-node02 ~]# cat &gt;/etc/docker/daemon.json &lt;&lt;EOF&#123; \"registry-mirrors\": [ \"https://registry.docker-cn.com\"] \"insecure-registries\":[\"172.16.194.130:5000\"]&#125;EOF[root@k8s-node01 ~]# systemctl restart docker 6、Jenkins安装1.编译镜像12345678910111213141516[root@k8s-node01 ~]# mkdir jenkins[root@k8s-node01~]# cd jenkins/[root@k8s-node01 jenkins]# cat DockerfileFROM jenkinsUSER rootRUN echo '' &gt; /etc/apt/sources.list.d/jessie-backports.list &amp;&amp; \\wget http://mirrors.163.com/.help/sources.list.jessie -O /etc/apt/sources.listRUN apt-get update &amp;&amp; apt-get install -y git[root@k8s-node01 jenkins]# docker build -t jenkins:v1 .Sending build context to Docker daemon 2.048kBStep 1/4 : FROM jenkins···中间略···---&gt; 8711202c6fdaSuccessfully built 8711202c6fdaSuccessfully tagged jenkins:v1 2.准备应用包在k8s-node01的宿主机上准备以下两个包，事先放在下面位置：12/usr/local/apache-maven-3.5.0/usr/local/jdk1.8.0_45 3. 运行Jenkins容器12345678docker run -d \\--name jenkins \\-p 8080:8080 \\-v /var/jenkins_home/:/var/jenkins_home \\-v /usr/local/apache-maven-3.5.0:/usr/local/maven \\-v /usr/local/jdk1.8.0_45:/usr/local/jdk \\-v ~/.ssh:/root/.ssh \\jenkins:v1 访问：http://172.16.194.129:8080/ 7、Jenkins基本配置 1.系统ssh连接配置点击：系统管理–&gt;系统管理（将页面拉到最后，配置ssh连接） 测试配置是否正常：Success，最后保存即可。 2.全局工具配置点击：系统管理–&gt; Global Tool Configuration 1.配置JDK环境2.git 默认即可3.配置maven 配置好了就保存。 8、Jenkins创建项目1.创建项目步骤新建–&gt;构建一个maven项目–&gt;点击ok 2.项目的一些配置2.1 配置git这里的git仓库配置，就是我们之前拉取的那个地址，分支指定master 2.2 构建触发器构建触发器，定制每小时出发一次，发现代码仓库有变化，就进行构建动作 2.3构建之前执行的动作123# 如果多次构建的话，需要清空上次构建的环境docker rm -f tale-test &amp;&amp; \\docker image rm 172.16.194.130:5000/tale:base 2.3构建之后执行的动作1234567# 构建好后，将环境使用docker运行到一个容器里，接下来就是测试啦！docker run -itd \\--name tale-test \\-p 88:80 \\-v /usr/local/jdk1.8.0_45:/usr/local/jdk \\-v /data/tale:/tale \\ # 这个构建后的Command一定是能在服务器上手动执行成功的，在这里才能执行成功。172.16.194.130:5000/tale:base 配置好后，应用–&gt;保存. 9、测试1、这是构建的结果12345678910111213141516# 第一次构建会比较慢，因为需要下载maven相关插件Started by user nicksors[EnvInject] - Loading node environment variables.Building in workspace /var/jenkins_home/workspace/tale-test &gt; git rev-parse --is-inside-work-tree # timeout=10···中间略···Digest: sha256:f82f2e175479d6d232efab45f81a4495cc4ad0a48135fd839dc27fdee8c13c77Status: Downloaded newer image for 172.16.194.130:5000/tale:baseccc80d6215724027d9111069b5c8afa48c0b9df5694386656d611e19796b34b3SSH: EXEC: completed after 21,474 msSSH: Disconnecting configuration [172.16.194.129] ...SSH: Transferred 183 file(s)Finished: SUCCESS 2、查看构建的docker运行情况运行良好，访问：http://172.16.194.129:88/12345[root@k8s-node01 ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESccc80d621572 172.16.194.130:5000/tale:base \"/usr/bin/supervisord\" 11 minutes ago Up 11 minutes 0.0.0.0:88-&gt;80/tcp tale-testaa80a34ec7b6 jenkins:v1 \"/bin/tini -- /usr/l…\" 20 hours ago Up 4 hours 0.0.0.0:8080-&gt;8080/tcp, 50000/tcp jenkins[root@k8s-node01 ~]# 3、tale博客运行起来啦！第一次访问会让你设置一下站点信息设置账号密码：nicksors/abc123!! 博客页面： 后台： CI/CD：持续集成/持续部署 的集成环境搞定~！","tags":[{"name":"CI/CD","slug":"CI-CD","permalink":"//nicksors.cc/tags/CI-CD/"},{"name":"持续集成","slug":"持续集成","permalink":"//nicksors.cc/tags/持续集成/"}]},{"title":"使用Compose打包部署Docker项目","date":"2018-05-15T07:02:30.000Z","path":"2018/05/15/使用Compose打包部署Docker项目.html","text":"前言：Docker Compose 是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括服务构建，启动和停止。一些学习资料:Docker Compose 配置文件详解:https://www.jianshu.com/p/2217cfed29d7Docker Compose 项目：https://yeasy.gitbooks.io/docker_practice/content/compose/ 一、Compose简介Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。 Compose 恰好满足了这样的需求。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。 Compose 中有两个重要的概念： 服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。 项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。 Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。 二、安装与卸载官网：https://docs.docker.com/compose/install/ 二进制包：1234# sudo curl -L https://github.com/docker/compose/releases/download/1.20.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose# sudo chmod +x /usr/local/bin/docker-compose[root@k8s-node02 ~]# docker-compose --versiondocker-compose version 1.20.1, build 5d8c71b PIP安装：1pip install -U docker-compose 卸载： 如果是二进制包方式安装的，删除二进制文件即可。1$ sudo rm /usr/local/bin/docker-compose 如果是通过 pip 安装的，则执行如下命令即可删除。1$ sudo pip uninstall docker-compose 三、使用首先介绍几个术语。 服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。 项目 (project)：由一组关联的应用容器组成的一个完整业务单元。 可见，一个项目可以由多个服务（容器）关联而成，Compose 面向项目进行管理。 案例一：构建web网站最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。 下面我们用 Python 来建立一个能够记录页面访问次数的 web 网站。 web应用 新建文件夹，在该目录中编写 app.py 文件12345678910111213141516[root@k8s-node02 ~]# mkdir web_server[root@k8s-node02 ~]# cd web_server/[root@k8s-node02 web_server]#vim app.pyfrom flask import Flaskfrom redis import Redisapp = Flask(__name__)redis = Redis(host='redis', port=6379)@app.route('/')def hello(): count = redis.incr('hits') return 'Hello World! 该页面已被访问 &#123;&#125; 次。\\n'.format(count)if __name__ == \"__main__\": app.run(host=\"0.0.0.0\", debug=True) Dockerfile 编写Dockerfile文件，内容为123456[root@k8s-node02 web_server]# cat DockerfileFROM python:3.6-alpineADD . /codeWORKDIR /codeRUN pip install redis flaskCMD [\"python\", \"app.py\"] docker-compase.yml编写 docker-compose.yml 文件，这个是 Compose 使用的主模板文件。1234567891011[root@k8s-node02 web_server]# cat docker-compose.ymlversion: '3'services: web: build: . ports: - \"5000:5000\" redis: image: \"redis:alpine\" 运行 compose 项目12345678910111213141516171819[root@k8s-node02 web_server]# docker-compose upBuilding webStep 1/5 : FROM python:3.6-alpine3.6-alpine: Pulling from library/python81033e7c1d6a: Already exists9b61101706a6: Pull complete35b21c1a8b97: Pull complete4856f5aeeec4: Pull complete84607ac623a4: Pull completeDigest: sha256:e10e26000b4dcfb66c52c11a6a7cc5251f6a95f9512fa9228bb3a66efc6c7075Status: Downloaded newer image for python:3.6-alpine---&gt; 4fcaf5fb5f2bStep 2/5 : ADD . /code---&gt; 061db7e464f1Step 3/5 : WORKDIR /codeRemoving intermediate container 7986a3cb8c7e---&gt; 92a3ea98dfffStep 4/5 : RUN pip install redis flask---&gt; Running in f0bed49a550d 此时访问本地 5000 端口，每次刷新页面，计数就会加 1。 注意事项 使用-d参数放入后台运行 docker-compose ps必须是在当前项目下执行，否则报错 1234567891011121314151617181920[root@k8s-node02 web_server]# docker-compose up -dStarting webserver_redis_1 ... doneStarting webserver_web_1 ... done[root@k8s-node02 web_server]#[root@k8s-node02 web_server]# docker-compose ps Name Command State Ports-----------------------------------------------------------------------------------webserver_redis_1 docker-entrypoint.sh redis ... Up 6379/tcpwebserver_web_1 python app.py Up 0.0.0.0:5000-&gt;5000/tcp[root@k8s-node02 web_server]#[root@k8s-node02 web_server]# cd[root@k8s-node02 ~]# docker-compose ps &lt;==找不到项目目录ERROR: Can't find a suitable configuration file in this directory or any parent. Are you in the right directory? Supported filenames: docker-compose.yml, docker-compose.yaml[root@k8s-node02 ~]# 案例二：一键部署LNMP网站平台项目结构12345678910111213141516171819[root@k8s-node02 compose_lnmp]# tree.├── docker-compose.yml # lnmp项目的yaml文件，默认文件名：docker-compose.yml，可更改├── mysql # 数据库目录│ ├── conf # 数据库配置目录│ │ └── my.cnf # 数据库配置文件│ └── data # 存储数据的目录（mysql的这些配置，是在容器起来所需要的东西）├── nginx # Nginx目录│ ├── Dockerfile # 会通过Dockerfile去构建Nginx│ ├── nginx-1.12.1.tar.gz│ └── nginx.conf├── php # PHP目录│ ├── Dockerfile # php 的Dockerfile文件│ ├── php-5.6.31.tar.gz│ └── php.ini # 配置文件└── wwwroot # 网站根目录 └── index.php6 directories, 9 files docker-compose.yml1234567891011121314151617181920212223242526272829303132333435363738394041424344[root@k8s-node02 compose_lnmp]# cat docker-compose.ymlversion: '3' # 版本，这里是指定compose的版本，compose有三个版本，分别为1、2、3；services: # 这里是一个顶级标签，这个是服务标签，下面定义了nginx、php、mysql等服务，当然今后你有多少个就写多少个。 nginx: # 具体服务名称 hostname: nginx # 服务的主机名 build: # 编译，同等于docker build Dockerfile ... context: ./nginx # 这里是指定Dockerfile的位置，这个位置是相对于docker-compose.yml所在位置而定的 dockerfile: Dockerfile # Dockerfile文件名称 ports: # 指定暴露的端口 - 81:80 networks: # 指定网络 - lnmp # 这里是具体的网络名称 volumes: # 映射的数据卷 - ./wwwroot:/usr/local/nginx/html php: hostname: php build: context: ./php dockerfile: Dockerfile networks: # 指定网络，要与Nginx、mysq同一个网络 - lnmp volumes: - ./wwwroot:/usr/local/nginx/html mysql: hostname: mysql image: mysql:5.6 # 要拉取的mysql容器镜像 ports: # 暴露的数据库端口 - 3306:3306 networks: # 指定到同一个网络 - lnmp volumes: # 映射数据卷 - ./mysql/conf:/etc/mysql/conf.d # ./mysql/conf是当前的目录，这里面有我们配置好的my.cnf配置文件 - ./mysql/data:/var/lib/mysql # ./mysql/data 这也是之前创建好的数据库data目录，用于存储mysql数据 command: --character-set-server=utf8 # 上面指定的mysql:5.6镜像在run的时候会接收到这个命令，并执行 environment: # 其他设置，这块属于数据库容器里的设置了，用户名、密码、要创建的数据库 MYSQL_ROOT_PASSWORD: 123456 MYSQL_DATABASE: wordpress MYSQL_USER: user MYSQL_PASSWORD: user123networks: # 这里是一个顶级标签，创建网络（compose会先执行顶级标签，然后在执行后面的，这里的体现就是会先创建网络，再安装Nginx、php、mysql） lnmp: # 指定要创建的网络名称 nginx:Dockerfile123456789101112131415161718[root@k8s-node02 compose_lnmp]# cat nginx/Dockerfile # 通过Dockerfile编译一个Nginx容器FROM centos:7 # 选择一个基础镜像MAINTAINER www.xxx.com # 作者名称 RUN yum install -y gcc gcc-c++ make openssl-devel pcre-devel # 初始安装包ADD nginx-1.12.1.tar.gz /tmp # 将本地的Nginx软件添加到容器的/tmp目录下RUN cd /tmp/nginx-1.12.1 &amp;&amp; \\ # 运行命令，解压和执行编译安装 ./configure --prefix=/usr/local/nginx &amp;&amp; \\ make -j 2 &amp;&amp; \\ make installRUN rm -rf /tmp/nginx-1.12.1* &amp;&amp; yum clean all # 清除一些不需要的东东COPY nginx.conf /usr/local/nginx/conf # 然后再拷贝我们准备好的Nginx配置文件WORKDIR /usr/local/nginx # 设置工作目录EXPOSE 80 # 开放80端口，注意这里是开放，是运行这个容器时会打开80端口，不是对外暴露端口CMD [\"./sbin/nginx\", \"-g\", \"daemon off;\"] #运行容器时所需要执行的命令 php:Dockerfile1234567891011121314151617181920212223242526# 上面说过的选项，这里就不在赘述了哈！[root@k8s-node02 compose_lnmp]# cat php/DockerfileFROM centos:7MAINTAINER www.xxx.comRUN yum install -y gcc gcc-c++ make gd-devel libxml2-devel libcurl-devel libjpeg-devel libpng-devel openssl-develADD php-5.6.31.tar.gz /tmp/RUN cd /tmp/php-5.6.31 &amp;&amp; \\ ./configure --prefix=/usr/local/php \\ --with-config-file-path=/usr/local/php/etc \\ --with-mysql --with-mysqli \\ --with-openssl --with-zlib --with-curl --with-gd \\ --with-jpeg-dir --with-png-dir --with-iconv \\ --enable-fpm --enable-zip --enable-mbstring &amp;&amp; \\ make -j 4 &amp;&amp; \\ make install &amp;&amp; \\ cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf &amp;&amp; \\ sed -i \"s/127.0.0.1/0.0.0.0/\" /usr/local/php/etc/php-fpm.conf &amp;&amp; \\ sed -i \"21a \\daemonize = no\" /usr/local/php/etc/php-fpm.confCOPY php.ini /usr/local/php/etcRUN rm -rf /tmp/php-5.6.31* &amp;&amp; yum clean allWORKDIR /usr/local/phpEXPOSE 9000CMD [\"./sbin/php-fpm\", \"-c\", \"/usr/local/php/etc/php-fpm.conf\"] 一键部署12345678[root@k8s-node02 compose_lnmp]# docker-compose up -d···一个漫长的编译、安装、拉取镜像过程···[root@k8s-node02 compose_lnmp]# docker-compose ps Name Command State Ports-------------------------------------------------------------------------------------composelnmp_mysql_1 docker-entrypoint.sh --cha ... Up 0.0.0.0:3306-&gt;3306/tcpcomposelnmp_nginx_1 ./sbin/nginx -g daemon off; Up 0.0.0.0:81-&gt;80/tcpcomposelnmp_php_1 ./sbin/php-fpm -c /usr/loc ... Up 9000/tcp 将WordPress下载到站点解压并安装，最终运行结果如下： 四、应用场景 互联网产品交付客户 将产品封装成docker compose文件项目文件，打包交付给客户；省却手动部署环境的麻烦，高效精简整个交付过程。 特制的环境应用 比如咱们经常部署的lnmp环境，那这种环境不希望重复部署，就可以编写好yaml文件，通过compase 来管理整个环境。","tags":[{"name":"Compose","slug":"Compose","permalink":"//nicksors.cc/tags/Compose/"}]},{"title":"使用cAdvisor+InfluxDB+Grafana构建容器监控系统","date":"2018-05-14T07:08:37.000Z","path":"2018/05/14/使用cAdvisor+InfluxDB+Grafana构建容器监控系统.html","text":"概述： cadvisor：数据采集 Influxdb：数据存储 grafana：数据展示 三个都直接下载镜像启动容器即可。 一、启动三个应用容器123456789101112131415161718192021222324252627282930313233343536# 先创建一个专属于他们几个小基友的网络docker network create monitor#InfluxDBdocker run -d \\--name=influxdb \\--net monitor \\-p 8083:8083 \\-p 8086:8086 \\tutum/influxdb# cAdvisordocker run -d \\--name=cadvisor \\--net monitor \\-p 8081:8080 \\--mount type=bind,src=/,dst=/rootfs,ro \\--mount type=bind,src=/var/run,dst=/var/run \\--mount type=bind,src=/sys,dst=/sys,ro \\--mount type=bind,src=/var/lib/docker,dst=/var/lib/docker,ro \\google/cadvisor \\-storage_driver=influxdb \\-storage_driver_db=cadvisor \\-storage_driver_host=influxdb:8086#Grafanadocker run -d \\--name=grafana \\--net monitor \\-p 3000:3000 \\grafana/grafana# 如果想让容器异常退出后重启，你需要加上下面的参数--restart=always 二、各个应用访问界面Grafana： http://172.16.194.130:3000/login 用户名和密码默认：admin InfluxDB： http://172.16.194.130:8083/ cAdvisor：http://172.16.194.130:8081/ 三、配置3.1、在influxdb里创建数据库，用于cadvisor存储数据CREATE DATABASE “cadvisor” 3.2、influxdb里创建一个用户，用于grafana连接influxdb数据库CREATE USER “grafana” WITH PASSWORD ‘grafana’ 3.3、grafana添加数据源 登录grafana –&gt;点击Add data source Type：选择influxdbURL：influxdb （monitor 网络互连，所以直接使用name名称即可）database: cadvisor 上面创建好的，账号密码也是填写之前创建好的 3.4、grafana创建Dashboard 添加过程及细节，自己研究，这里不做输出 最终添加的结果，这里只是添加了两个示例 那么，“容器监控系统” 解决方案在这里就结束了，期待更多的玩法ing.","tags":[{"name":"cAdvisor","slug":"cAdvisor","permalink":"//nicksors.cc/tags/cAdvisor/"},{"name":"InfluxDB","slug":"InfluxDB","permalink":"//nicksors.cc/tags/InfluxDB/"},{"name":"Grafana","slug":"Grafana","permalink":"//nicksors.cc/tags/Grafana/"}]},{"title":"Docker图形界面管理Portainer","date":"2018-05-14T06:48:38.000Z","path":"2018/05/14/Docker图形界面管理Portainer.html","text":"官网：https://portainer.io/ 一、创建卷1docker volume create portainer_data 二、创建portainer容器 (默认可以自动创建卷)123456# docker run -d \\--name portainer \\-p 9000:9000 \\-v /var/run/docker.sock:/var/run/docker.sock \\-v portainer_data:/data \\portainer/portainer 三、配置portainerhttp://172.16.194.130:9000/ 用户名默认：admin需要设置密码，输入：abc123!! 选择本地或远程连接，我这里选择本地，点击Connect 这是整个管理页面的全貌，自己研究玩吧~","tags":[{"name":"portainer","slug":"portainer","permalink":"//nicksors.cc/tags/portainer/"}]},{"title":"搭建Hexo博客所用到的技术","date":"2018-05-10T08:43:55.000Z","path":"2018/05/10/搭建Hexo所用到的技术.html","text":"前言：这里记录着我搭建博客时用到了以下技术，基本上是参考各位博友写的博文。为了防止哪天我的博客崩掉后，我还能想起来如何重建它。 Mac上hexo博客的搭建 hexo使用yilia主题 Gitment：使用 GitHub Issues 搭建评论系统 添加gitment评论系统 添加Gitment评论系统踩过的坑（这些坑我全部踩了一遍…） 遇到的坑：点击login会url链接报错 hexo yilia主题添加文章访问量统计 百度、谷歌统计配置 网站访问量显示 Hexo七牛插件安装与使用 以上，非常感谢各位博友的辛苦总结.","tags":[{"name":"Heox","slug":"Heox","permalink":"//nicksors.cc/tags/Heox/"}]},{"title":"Docker企业级私有仓库方案(harbor)","date":"2018-05-10T06:37:16.000Z","path":"2018/05/10/Docker企业级私有仓库方案(harbor).html","text":"前言： Docker Hub作为Docker默认官方公共镜像，如果自己想搭建私有镜像仓库，官网也提供registry镜像，使得搭建私有仓库非常简单。 一、搭建私有镜像仓库:registry1.1、下载registry镜像并启动12$ docker pull registry$ docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 --restart=always --name registry registry 1.2、测试，查看镜像仓库中所有镜像12[root@k8s-node02 ~]# curl http://127.0.0.1:5000/v2/_catalog&#123;&quot;repositories&quot;:[]&#125; 1.3、私有镜像仓库管理1）配置私有仓库可信任1234567891011$ vim /etc/docker/daemon.json&#123;\"insecure-registries\":[\"127.0.0.1:5000\"]&#125;systemctl restart docker这里需要注意一点，如果daemon.json里已经有配置，\"需要在原有配置后面加逗号，不然失效\" 譬如：[root@k8s-node02 ~]# cat /etc/docker/daemon.json&#123; \"registry-mirrors\": [ \"https://registry.docker-cn.com\"], \"insecure-registries\": [\"172.16.194.130:5000\"]&#125; 2）打标签1$ docker tag centos:6 127.0.0.1:5000/centos:7 3）上传1$ docker push 127.0.0.1:5000/centos:7 4）下载1$ docker pull 127.0.0.1:5000/centos:7 5）列出镜像标签12[root@k8s-node02 ~]# curl http://127.0.0.1:5000/v2/centos/tags/list&#123;\"name\":\"centos\",\"tags\":[\"7\"]&#125; 注意：127.0.0.1可以换成你网卡的地址 二、Docker Hub公共镜像仓库使用因为dockerHub是国外的服务器，push和pull操作都比较慢，甚至有连接超时的情况，个人研究玩玩还是可以的。https://cloud.docker.com/swarm/nicksors 1）注册帐号https://hub.docker.com 2）登录Docker Hub12345$ docker login或[root@k8s-node02 ~]# docker login --username=nicksors --password=与GitHub密码一样WARNING! Using --password via the CLI is insecure. Use --password-stdin.Login Succeeded 3）镜像打标签1$ docker tag nginx:1.12 nicksors/nginx:v2 4）上传1$ docker push nicksors/nginx:v2 5）下载1$ docker pull nicksors/nginx:v2 三、基于Harbor搭建Docker私有镜像仓库（推荐:很多企业都用这个）3.1、什么是Harbor？Harbor是VMware开源的又一个Docker Registry企业级私有仓库，其项目地址为https://github.com/vmware/harbor；相比Docker公司自己提供的Registry私有镜像仓库而言，Harbor提供了更多的功能，如下： 基于角色的访问控制 - 用户与Docker镜像仓库通过“项目”进行组织管理，一个用户可以对多个镜像仓库在同一命名空间（project）里有不同的权限。 镜像复制 - 镜像可以在多个Registry实例中复制（同步）。尤其适合于负载均衡，高可用，混合云和多云的场景。 图形化用户界面 - 用户可以通过浏览器来浏览，检索当前Docker镜像仓库，管理项目和命名空间。 AD/LDAP 支持 - Harbor可以集成企业内部已有的AD/LDAP，用于鉴权认证管理。 审计管理 - 所有针对镜像仓库的操作都可以被记录追溯，用于审计管理。 国际化 - 已拥有英文、中文、德文、日文和俄文的本地化版本。更多的语言将会添加进来。 RESTful API - RESTful API 提供给管理员对于Harbor更多的操控, 使得与其它管理软件集成变得更容易。 部署简单 - 提供在线和离线两种安装工具， 也可以安装到vSphere平台(OVA方式)虚拟设备。 以上来自官网介绍：https://vmware.github.io/harbor/cn/ 3.2、准备环境 自己创建的虚拟机：CentOS7.2、配置是2G2C； Docker版本：Docker version 18.03.0-ce Docker-compose：docker-compose version 1.20.1 Harbor版本：harbor-offline-installer-v1.4.0.tgz 3.3、安装Harbor在安装Harbor之前，必须保证你的环境已经安装好docker和docker-compose了,这两个安装方法在Docker官网都有：12安装Docker方法：https://docs.docker.com/install/linux/docker-ce/centos安装Docker-Compose方法：https://docs.docker.com/compose/install/#install-compose 你可以在 Harbor版本https://github.com/vmware/harbor/releases 地址下载你想要装的版本，这里我选择最新的1.4.0，当然你看到的时候已经不是最新版本了。123# 选择离线安装版本$ wget https://storage.googleapis.com/harbor-releases/release-1.4.0/harbor-offline-installer-v1.4.0.tgz（如果下载慢的话，你可以使用迅雷下载，有的网友就这么干，会快很多） 解压下载的包，进入解压后的harbor目录，里面有个harbor.cfg就是配置文件啦，简单说下：这里面可以配置LDAP，数据库，邮件信息，ssl证书等。12345$ vim harbor.cfg# 我配置了两个地方，主机名和Harbor admin的密码，其他默认hostname = 172.16.194.130harbor_admin_password = abc123!! 下面奉上一份harbor.cfg的关键参数说明：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145## Configuration file of Harbor#hostname设置访问地址，可以使用ip、域名，不可以设置为127.0.0.1或localhosthostname = 172.16.194.130 #这里我使用本机IP# 访问协议，默认是http，也可以设置https，如果设置https，则nginx ssl需要设置onui_url_protocol = http#Maximum number of job workers in job servicemax_job_workers = 3#Determine whether or not to generate certificate for the registry's token.#If the value is on, the prepare script creates new root cert and private key#for generating token to access the registry. If the value is off the default key/cert will be used.#This flag also controls the creation of the notary signer's cert.customize_crt = on# 指定的证书文件，生产环境一定要使用ssl证书ssl_cert = /data/cert/server.crtssl_cert_key = /data/cert/server.key# 存放证书的路径,这个路径会挂载到宿主机的/data/目录下secretkey_path = /data#Admiral's url, comment this attribute, or set its value to NA when Harbor is standaloneadmiral_url = NA#Log files are rotated log_rotate_count times before being removed. If count is 0, old versions are removed rather than rotated.log_rotate_count = 50#Log files are rotated only if they grow bigger than log_rotate_size bytes. If size is followed by k, the size is assumed to be in kilobytes.#If the M is used, the size is in megabytes, and if G is used, the size is in gigabytes. So size 100, size 100k, size 100M and size 100G#are all valid.log_rotate_size = 200M#************************BEGIN INITIAL PROPERTIES************************# 配置邮件server信息email_identity =email_server = smtp.mydomain.comemail_server_port = 25email_username = sample_admin@mydomain.comemail_password = abcemail_from = admin &lt;sample_admin@mydomain.com&gt;email_ssl = falseemail_insecure = false# 启动Harbor后，管理员UI登录的密码，默认是Harbor12345harbor_admin_password = abc123!!# 认证方式，这里支持多种认证方式，如LADP、本次存储、数据库认证。默认是db_auth，mysql数据库认证auth_mode = db_auth# ldap配置ldap_url = ldaps://ldap.mydomain.com#A user's DN who has the permission to search the LDAP/AD server.#If your LDAP/AD server does not support anonymous search, you should configure this DN and ldap_search_pwd.#ldap_searchdn = uid=searchuser,ou=people,dc=mydomain,dc=com#the password of the ldap_searchdn#ldap_search_pwd = password#The base DN from which to look up a user in LDAP/ADldap_basedn = ou=people,dc=mydomain,dc=com#Search filter for LDAP/AD, make sure the syntax of the filter is correct.#ldap_filter = (objectClass=person)# The attribute used in a search to match a user, it could be uid, cn, email, sAMAccountName or other attributes depending on your LDAP/ADldap_uid = uid#the scope to search for users, 0-LDAP_SCOPE_BASE, 1-LDAP_SCOPE_ONELEVEL, 2-LDAP_SCOPE_SUBTREEldap_scope = 2#Timeout (in seconds) when connecting to an LDAP Server. The default value (and most reasonable) is 5 seconds.ldap_timeout = 5#Verify certificate from LDAP serverldap_verify_cert = true#Turn on or off the self-registration featureself_registration = on#The expiration time (in minute) of token created by token service, default is 30 minutestoken_expiration = 30# 用户创建项目权限控制，默认是everyone（所有人），也可以设置为adminonly（只能管理员）project_creation_restriction = everyone#************************END INITIAL PROPERTIES************************#######Harbor DB configuration section########The address of the Harbor database. Only need to change when using external db.db_host = mysql#The password for the root user of Harbor DB. Change this before any production use.db_password = root123#The port of Harbor database hostdb_port = 3306#The user name of Harbor databasedb_user = root##### End of Harbor DB configuration########The redis server address. Only needed in HA installation.redis_url =##########Clair DB configuration#############Clair DB host address. Only change it when using an exteral DB.clair_db_host = postgres#The password of the Clair's postgres database. Only effective when Harbor is deployed with Clair.#Please update it before deployment. Subsequent update will cause Clair's API server and Harbor unable to access Clair's database.clair_db_password = password#Clair DB connect portclair_db_port = 5432#Clair DB usernameclair_db_username = postgres#Clair default databaseclair_db = postgres##########End of Clair DB configuration#############The following attributes only need to be set when auth mode is uaa_authuaa_endpoint = uaa.mydomain.orguaa_clientid = iduaa_clientsecret = secretuaa_verify_cert = trueuaa_ca_cert = /path/to/ca.pem### Docker Registry setting ####registry_storage_provider can be: filesystem, s3, gcs, azure, etc.registry_storage_provider_name = filesystem#registry_storage_provider_config is a comma separated \"key: value\" pairs, e.g. \"key1: value, key2: value2\".#Refer to https://docs.docker.com/registry/configuration/#storage for all available configuration.registry_storage_provider_config = 3.4、启动Harbor修改完配置文件后，在的当前目录执行./install.sh，Harbor服务就会根据当期目录下的docker-compose.yml开始下载依赖的镜像，检测并按照顺序依次启动各个服务。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889$ ./install.sh[Step 0]: checking installation environment ...Note: docker version: 18.03.0Note: docker-compose version: 1.20.1[Step 1]: loading Harbor images ...Loaded image: vmware/notary-server-photon:v0.5.1-v1.4.0Loaded image: vmware/notary-signer-photon:v0.5.1-v1.4.0Loaded image: vmware/harbor-db:v1.4.0Loaded image: vmware/clair-photon:v2.0.1-v1.4.0Loaded image: vmware/postgresql-photon:v1.4.0Loaded image: vmware/harbor-adminserver:v1.4.0Loaded image: vmware/harbor-ui:v1.4.0Loaded image: vmware/harbor-log:v1.4.0Loaded image: vmware/harbor-jobservice:v1.4.0Loaded image: vmware/nginx-photon:v1.4.0Loaded image: vmware/registry-photon:v2.6.2-v1.4.0Loaded image: vmware/photon:1.0Loaded image: vmware/mariadb-photon:v1.4.0Loaded image: vmware/harbor-db-migrator:1.4[Step 2]: preparing environment ...Clearing the configuration file: ./common/config/adminserver/envClearing the configuration file: ./common/config/ui/envClearing the configuration file: ./common/config/ui/app.confClearing the configuration file: ./common/config/ui/private_key.pemClearing the configuration file: ./common/config/db/envClearing the configuration file: ./common/config/jobservice/envClearing the configuration file: ./common/config/jobservice/app.confClearing the configuration file: ./common/config/registry/config.ymlClearing the configuration file: ./common/config/registry/root.crtClearing the configuration file: ./common/config/nginx/nginx.confClearing the configuration file: ./common/config/log/logrotate.confloaded secret from file: /data/secretkeyGenerated configuration file: ./common/config/nginx/nginx.confGenerated configuration file: ./common/config/adminserver/envGenerated configuration file: ./common/config/ui/envGenerated configuration file: ./common/config/registry/config.ymlGenerated configuration file: ./common/config/db/envGenerated configuration file: ./common/config/jobservice/envGenerated configuration file: ./common/config/log/logrotate.confGenerated configuration file: ./common/config/jobservice/app.confGenerated configuration file: ./common/config/ui/app.confGenerated certificate, key file: ./common/config/ui/private_key.pem, cert file: ./common/config/registry/root.crtThe configuration files are ready, please use docker-compose to start the service.[Step 3]: checking existing instance of Harbor ...[Step 4]: starting Harbor ...Creating harbor-log ... doneCreating harbor-db ... doneCreating registry ... doneCreating harbor-adminserver ... doneCreating harbor-ui ... doneCreating nginx ... doneCreating harbor-jobservice ... done✔ ----Harbor has been installed and started successfully.----Now you should be able to visit the admin portal at http://172.16.194.130.For more details, please visit https://github.com/vmware/harbor .# 这时候你可以通过docker-compose 或docker ps来查看Harbor依赖运行的一些容器# 当然你也可以通过docker-compose来管理这些容器[root@k8s-node02 harbor]# docker-compose ps Name Command State Ports-------------------------------------------------------------------------------------------------------------------------------------harbor-adminserver /harbor/start.sh Up (healthy)harbor-db /usr/local/bin/docker-entr ... Up (healthy) 3306/tcpharbor-jobservice /harbor/start.sh Up (healthy)harbor-log /bin/sh -c /usr/local/bin/ ... Up (healthy) 127.0.0.1:1514-&gt;10514/tcpharbor-ui /harbor/start.sh Up (healthy)nginx nginx -g daemon off; Up 0.0.0.0:443-&gt;443/tcp, 0.0.0.0:4443-&gt;4443/tcp, 0.0.0.0:80-&gt;80/tcpregistry /entrypoint.sh serve /etc/ ... Up (healthy) 5000/tcp[root@k8s-node02 harbor]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESbaf9d3e586f8 vmware/harbor-jobservice:v1.4.0 \"/harbor/start.sh\" About an hour ago Up About an hour (healthy) harbor-jobservice484d5c4fca4b vmware/nginx-photon:v1.4.0 \"nginx -g 'daemon of…\" About an hour ago Up About an hour 0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp, 0.0.0.0:4443-&gt;4443/tcp nginxdd7c62b45af1 vmware/harbor-ui:v1.4.0 \"/harbor/start.sh\" About an hour ago Up About an hour (healthy) harbor-uie5494bd12f64 vmware/registry-photon:v2.6.2-v1.4.0 \"/entrypoint.sh serv…\" About an hour ago Up About an hour (healthy) 5000/tcp registry915b753623b7 vmware/harbor-adminserver:v1.4.0 \"/harbor/start.sh\" About an hour ago Up About an hour (healthy) harbor-adminserver55ca16b86243 vmware/harbor-db:v1.4.0 \"/usr/local/bin/dock…\" About an hour ago Up About an hour (healthy) 3306/tcp harbor-db30ca0cb76dd0 vmware/harbor-log:v1.4.0 \"/bin/sh -c /usr/loc…\" About an hour ago Up About an hour (healthy) 127.0.0.1:1514-&gt;10514/tcp 3.5、登录Harbor启动完成后，会提示你Harbor的访问地址：http://172.16.194.130 登录界面 输入账号和我们预先设定的密码：admin/abc123!! 我们可以看到系统各个模块如下： 项目：新增/删除项目，查看镜像仓库，给项目添加成员、查看操作日志、复制项目等 日志：仓库各个镜像create、push、pull等操作日志 系统管理 用户管理：新增/删除用户、设置管理员等 复制管理：新增/删除从库目标、新建/删除/启停复制规则等 配置管理：认证模式、复制、邮箱设置、系统设置等 其他设置 用户设置：修改用户名、邮箱、名称信息 修改密码：修改用户密码 注意：非系统管理员用户登录，只能看到有权限的项目和日志，其他模块不可见。 3.6、向Harbor仓库中心提交私有镜像我们要尝试下能不能把自己 Docker 里面的镜像 push 到 Harbor 的 library 里来（默认这个 library 项目是公开的，所有人都可以有读的权限，都不需要 docker login 进来，就可以拉取里面的镜像）。 3.6.1、配置Docker registry仓库地址在/etc/docker/daemon.json里添加配置如下：123&#123; &quot;insecure-registries&quot;: [&quot;172.16.194.130&quot;]&#125; 配置好后，别忘了重启systemctl restart docker 3.6.2、Docker 登录Harbor为什么要登录呢？跟Docker Hub一样，你得登录才能表明你是合法用户，才能push；1234$ docker login 172.16.194.130Username: adminPassword: (这里输入harbor平台设置的admin密码)Login Succeeded 3.6.3、本地私有镜像打tag，提交到Harbor1234567891011$ docker tag tale:base 172.16.194.130/library/tale:base$ docker push 172.16.194.130/library/taleThe push refers to repository [172.16.194.130/library/tale]a3ece4722ead: Pusheded61150eb02c: Pushed0f9f3d37a459: Pushed8ed018b01f91: Pushedb17185091796: Pushedb03095563b79: Pushedbase: digest: sha256:f82f2e175479d6d232efab45f81a4495cc4ad0a48135fd839dc27fdee8c13c77 size: 1574 提交成功，我们来看看Harbor仓库里的信息 能看到已经提交到libary公共仓库中。 同理，你也可以测试下从 Harbor pull 镜像到你的 Docker 中去，操作如下：12345678$ docker rmi 172.16.194.130/library/tale:base$ docker pull 172.16.194.130/library/tale:basebase: Pulling from library/taleDigest: sha256:f82f2e175479d6d232efab45f81a4495cc4ad0a48135fd839dc27fdee8c13c77Status: Downloaded newer image for 172.16.194.130/library/tale:base[root@k8s-node02 harbor]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE172.16.194.130/library/tale base ab8e3ca33cd0 5 days ago 372MB 镜像在被我删除后，从Harbor里成功pull了回来。 3.7、Harbor配置ssl认证3.7.1、创建证书1$ cd /data/cert/ 1、创建 CA 根证书1$ openssl req -newkey rsa:4096 -nodes -sha256 -keyout ca.key -x509 -days 365 -out ca.crt -subj &quot;/C=CN/L=xian/O=nova/CN=harbor-registry&quot; 2、生成一个证书签名, 设置访问域名为harbor.moxiu.cn1$ openssl req -newkey rsa:4096 -nodes -sha256 -keyout harbor.moxiu.cn.key -out server.csr -subj &quot;/C=CN/L=xian/O=nova/CN=harbor.moxiu.cn&quot; 3、生成主机的证书1$ openssl x509 -req -days 365 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out harbor.moxiu.cn.crt 3.7.2、配置harbor以https方式访问12345$ vim harbor.cfghostname = harbor.moxiu.cn:443ui_url_protocol = httpsssl_cert = /data/cert/harbor.moxiu.cn.crtssl_cert_key = /data/cert/harbor.moxiu.cn.key 3.7.3、配置Docker registry仓库地址在/etc/docker/daemon.json里添加配置如下：123&#123; \"insecure-registries\": [\"harbor.moxiu.cn\"]&#125; 然后，重启docker服务生效 3.7.4、登录验证1、验证admin登录方法11234$ docker login harbor.moxiu.cnUsername (admin): adminPassword: Login Succeeded 2、验证admin登录方法212$ docker login -u admin -p abc123!! harbor.moxiu.cnLogin Succeeded 3、Web页面登录验证http://harbor.moxiu.cn/harbor/sign-in用户名/密码：admin/abc123!! 因为不是有效机构颁发的证书，所有浏览器会提示不安全。如果企业需要使用，那需要买商用的证书更换即可。","tags":[{"name":"harbor","slug":"harbor","permalink":"//nicksors.cc/tags/harbor/"}]}]