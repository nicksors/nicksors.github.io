[{"title":"电影：爆裂鼓手","date":"2018-05-17T17:21:26.000Z","path":"2018/05/18/电影：爆裂鼓手.html","text":"http://www.le.com/ptv/vplay/29937749.html#vid=29937749 20180518：凌晨01:04分 刚看完爆裂鼓手，看完最后一段后，我知道，又一个查理·帕克诞生了，从魔鬼导师的眼里能看出来。 此时的我眼里少许热泪，想到了自己人生里是否也能出现一位这样的魔鬼导师？压迫到自己喘不过气来。 魔鬼导师在与安德鲁对话中，导师说道一句话让我特别感触，他说：“我是去逼他们突破自己的极限的”。这句话特别触动了我。 我现在24周岁，非常希望在30岁之前能遇到我的魔鬼导师，能逼迫我挑战自己的极限。 在我成长的同时，我也需要学习魔鬼导师的精神，去找到属于我的查理·帕克！ 这个片子值得我过几年后再次看看，那时候我应该是热泪盈眶，到那时希望溜的不是泪水，而是故事。 同样适合我被上司，公司等对我严厉，严格的人事物们，特别是有种上班入上坟的感觉时，最应该看看这个片子，我应该会想通，过几年后我拿着高薪，生活过得美满时，应该感谢的人是谁！","tags":[{"name":"电影","slug":"电影","permalink":"//nicksors.cc/tags/电影/"}]},{"title":"Kubernetes是什么？","date":"2018-05-17T04:08:29.000Z","path":"2018/05/17/Kubernetes是什么？.html","text":"这是一篇从零开始了解Kubernetes的理论文章，从概念介绍到其关键技术再到架构设计，都能帮助我能更好的理解Kubernetes。 一、Kubernetes简介 Kubernetes是Google在2014年6月开园的一个容器集群管理系统，该系统使用Google研发的Golang语言开发。Kubernetes也被叫做k8s，因为k和s之前有8个字母。 k8s原本是Google内部一个叫Borg的容器集群管理系统衍生出来的，Borg已经在Google大规模生产运行十年之久。 k8s主要用于自动化部署、扩展和管理容器应用，它提供了资源调度、部署管理、服务发现、扩容缩容、监控等一整套功能。 Kubernetes的目标是让部署容器化应用简单高效。官网地址：https://www.kubernetes.io 二、Kubernetes主要功能2.1、数据卷在Pod中，容器之前共享数据，可以使用数据卷。这个功能与docker里volume功能相等。 2.2、应用程序健康检查检查容器内的服务、进程是否异常；可以设置监控检测策略来保证应用的健壮性。 2.3、复制应用程序实例控制维护Pod副本数，保证一个Pod或一组同类的Pod数始终可用。 2.4、弹性缩容根据设定的指标（CPU利用率）自动缩放Pod副本数。 2.5、服务发现使用环境变量或DOS服务插件保证容器中程序发现Pod入口访问地址。 2.6、负载均衡一组Pod副本分配一个私有的集群IP地址，负载均衡转发请求到后端容器。在集群内部，其他Pod可通过这个ClusterIP访问应用。 2.7、滚动更新更新服务不中断，异常更新一个Pod，而不是同时删除整个服务。 2.8、服务编排通过文件描述部署服务，使得应用程序部署变得更高效。 2.9、资源监控Node节点组件继承CAdvisor资源收集工具，可通过Heapster汇总整个集群节点资源数据，然后存储到InfluxDB时序数据库中，再由Grafana展示。 2.10、提供认证和授权支持角色访问控制（RBAC）认证授权等策略。 三、基本概念 在k8s中，它的概念非常的多！而且一定要去了解这些概念，知道它的作用是必须的，你需要知道这些概念，才能更好的应用它。 3.1、PodPod是k8s最小部署单元，一个Pod有一个或多个容器组成，Pod中容器共享存储和网络，在同一个Docker主机上运行。官网解读：https://www.kubernetes.org.cn/kubernetes-pod 3.2、ServiceService一个应用服务的抽象，定义了Pod逻辑集合和访问这个Pod集合的策略。官网解读：https://www.kubernetes.org.cn/kubernetes-services 3.3、Volume数据卷，共享Pod中容器使用的数据。官网解读：https://www.kubernetes.org.cn/kubernetes-volumes 3.4、Namespace命名空间将对象逻辑上分配到不同Namespace，可以是不同的项目、用户等分区管理，并设定控制策略，从而实现多租户。官网解读：https://www.kubernetes.org.cn/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%EF%BC%9Anamespace 3.5、Lable标签用于区分对象（比如Pod、Service），键/值对存在；每个对象可以有多个标签，通过标签关联对象。官网解读：https://www.kubernetes.org.cn/kubernetes-labels 四、更高层次的抽象4.1、ReplicaSet（RS）ReplicaSet是下一代复本控制器。官网解读：https://www.kubernetes.org.cn/replicasets 4.2、DeploymentDeployment是一个更高层次的API对象，它管理ReplicaSets和Pod，并提供声明式更新等功能。官方建议使用Department管理ReplicaSets,而不是直接使用ReplicaSets，这就意味着可能永远不需要直接操作ReplicaSet对象。 咱们在实际应用当中，基本上都是去创建一个Deployment，然后由Deployment去创建RS和Pod等。官网解读：https://www.kubernetes.org.cn/deployment 4.3、StatefulSetStatefulSet适合持久性的应用程序，有唯一的网络标识符（IP），持久存储，有序的部署、扩展、删除和滚动更新。官网解读：https://www.kubernetes.org.cn/statefulset 4.4、DaemonSetDaemonSet确保所有（或一些）节点运行同一个Pod。当节点加入Kubernetes集群中，Pod会被调度到该节点上运行，当节点从集群中移除时，DaemonSet的Pod会被删除。删除DaemonSet会清理它所有创建的Pod。官网解读：https://www.kubernetes.org.cn/daemonset 4.5、Job一次性任务，运行完成后Pod销毁，不在重新启动新容器。还可以任务定时运行。官网解读：https://www.kubernetes.org.cn/job 五、Kubernetes系统架构拓扑图 六、组件功能介绍6.1、Master组件 kube-apiserverKubernetes API，集群的统一入口，各组件协调者。以HTTP API提供接口服务，所有对象的增删改查和监听操作都交给API Server处理后再提交给Etcd存储。 kube-controller-master处理集群中常规后台任务，一个资源对应一个控制器，而ControllerManager就是负责管理这些控制器的。 kube-scheduler根据调度算法为新创建的Pod选择一个Node节点。 6.2、Node组件 kubeletkubelet是Master在Node节点上的Agent，管理本机运行容器的生命周期，比如创建容器、Pod挂载数据卷、下载secret、获取容器和节点状态等工作。kubelet将每个Pod转换成一组容器。 kube-proxy在Node节点上实现Pod网络代理，维护网络规则和四层负载均衡工作。 docker或rocket/rktk8s可选的容器运行底层支持技术，一般我们都使用docker。 6.3、第三方服务 etcd分布式键值存储系统。用于保持集群状态，比如Pod、Service等对象信息。 本文完.","tags":[]},{"title":"使用Docker构建持续集成环境","date":"2018-05-16T06:02:21.000Z","path":"2018/05/16/使用Docker构建持续集成环境.html","text":"前言：本文将使用Docker+Git+Maven+Jenkins构建一套持续集成环境，可上线生产，本文内容请酌情参考. 0、服务器部署规划 服务名称 主机名 IP 开发机客户端 k8s-mster 1 72.16.194.128 测试服务器（Docker）、Jenkins服务器 k8s-node01 172.16.194.129 Git/Docker registry k8s-node02 172.16.194.130 ———-我是分割线——— 工具 版本 CentOS 7.2_x64 Maven 3.5 Tomcat 8 JDK 1.8 Jenkins 2.6 Docker CE 18.03 1、CI/CD 2、发布流程设计 3、部署Git服务器1.安装git[root@k8s-node02 ~]# yum install git -y 2.创建用户useradd git passwd git 3.创建仓库su - git mkdir app.git git --bare init app.git 4.克隆仓库在另外的节点上操作 [root@k8s-master ~]# yum install git -y [root@k8s-master ~]# git clone git@172.16.194.130:/home/git/app.git 正克隆到 &#39;app&#39;... The authenticity of host &#39;172.16.194.130 (172.16.194.130)&#39; can&#39;t be established. ECDSA key fingerprint is 60:eb:ee:4d:7d:12:10:5d:49:0c:7a:f3:81:5d:1f:2b. Are you sure you want to continue connecting (yes/no)? yss Warning: Permanently added &#39;172.16.194.130&#39; (ECDSA) to the list of known hosts. git@172.16.194.130&#39;s password: warning: 您似乎克隆了一个空版本库。 [root@k8s-master ~]# cd app/ [root@k8s-master app]# ls -lh 总用量 0 [root@k8s-master app]# 5.生成秘钥对，配置免密clone[root@k8s-master ~]# ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. The key fingerprint is: 5a:f9:66:7a:53:5a:2c:f9:a4:bc:98:5e:29:7d:2d:6f root@k8s-master The key&#39;s randomart image is: +--[ RSA 2048]----+ | | | | | | | . | | S o | | o oo.=. | | . ..BOo . | | O*..oE | | .=..o .. | +-----------------+ [root@k8s-master ~]# ls -lh /root/.ssh/ 总用量 12K -rw------- 1 root root 1.7K 3月 29 18:46 id_rsa -rw-r--r-- 1 root root 397 3月 29 18:46 id_rsa.pub -rw-r--r-- 1 root root 176 3月 29 17:57 known_hosts [root@k8s-master ~]# ssh-copy-id git@172.16.194.130 /usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed /usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys git@172.16.194.130&#39;s password: Number of key(s) added: 1 Now try logging into the machine, with: &quot;ssh &#39;git@172.16.194.130&#39;&quot; and check to make sure that only the key(s) you wanted were added. [root@k8s-master ~]# # 查看master节点cp过来的秘钥 [root@k8s-node02 ~]# su - git 上一次登录：四 3月 29 17:52:09 CST 2018pts/1 上 [git@k8s-node02 ~]$ ls -lh .ssh/authorized_keys -rw-------. 1 git git 397 Mar 29 18:49 .ssh/authorized_keys [git@k8s-node02 ~]$ cat !$ cat .ssh/authorized_keys ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDHp/RZmgz5R5Nw1pQXyPjVynDu0kkn/3i05WR7CRNS31ylGkkI5k7AOmw8sEEDn3mAQg/z/xEI+LIoCRu68MESJEkqXX2oHzsEa6/JB6X3OW4VIwAkwD8W1FUppK1dueAmnZmx4k7ZiIgE43QWxcOuDthQ2mO3ybWjk13tR0viz4mrcuK/ulkW5AOlLP1I2A4NkTVmkXktk/CuTrULph/VXz10kbX+u0OPNxDLGzUdC94Issm4IPZRwYBhgYviCNEIxZW2pBrpnL3rXmVHHE4eeNGNJ0DnhaX32p4wYAKqujU1VK7udED2Af9rYgE9yArRfTc53di6OXTrlJ7polG/ root@k8s-master # 删除app项目后，重新clone就不需要密码了 [root@k8s-master ~]# git clone git@172.16.194.130:/home/git/app.git 正克隆到 &#39;app&#39;... warning: 您似乎克隆了一个空版本库。 6.克隆博客系统，提交到自建git仓库1.git clone tale [root@k8s-master ~]# git clone https://github.com/otale/tale.git 2.提交到我们自己的git仓库里 [root@k8s-master ~]# \\cp -a tale/* app/ [root@k8s-master ~]# ls -lh app/ 总用量 24K drwxr-xr-x 2 root root 21 3月 29 18:45 bin -rw-r--r-- 1 root root 1.1K 3月 29 18:45 LICENSE -rw-r--r-- 1 root root 1.5K 3月 29 18:45 package.xml -rw-r--r-- 1 root root 7.1K 3月 29 18:45 pom.xmlf -rw-r--r-- 1 root root 2.8K 3月 29 18:45 README.md -rw-r--r-- 1 root root 2.7K 3月 29 18:45 README_ZH.md drwxr-xr-x 3 root root 17 3月 29 18:45 src [root@k8s-master app]# git add . [root@k8s-master app]# git status [root@k8s-master app]# git config --global user.email &quot;you@example.com&quot; # 这两步需要执行下，内容随便，不然commit时会提示 [root@k8s-master app]# git config --global user.name &quot;Your Name&quot; [root@k8s-master app]# git commit -m &#39;all&#39; [root@k8s-master app]# git push warning: push.default 未设置，它的默认值将会在 Git 2.0 由 &#39;matching&#39; 修改为 &#39;simple&#39;。若要不再显示本信息并在其默认值改变后维持当前使用习惯， 进行如下设置： git config --global push.default matching 若要不再显示本信息并从现在开始采用新的使用习惯，设置： git config --global push.default simple 参见 &#39;git help config&#39; 并查找 &#39;push.default&#39; 以获取更多信息。 （&#39;simple&#39; 模式由 Git 1.7.11 版本引入。如果您有时要使用老版本的 Git， 为保持兼容，请用 &#39;current&#39; 代替 &#39;simple&#39; 模式） No refs in common and none specified; doing nothing. Perhaps you should specify a branch such as &#39;master&#39;. fatal: The remote end hung up unexpectedly error: 无法推送一些引用到 &#39;git@172.16.194.130:/home/git/app.git&#39; [root@k8s-master app]# git push origin master # 需要提交到origin master 主干仓库 Counting objects: 297, done. Delta compression using up to 4 threads. Compressing objects: 100% (255/255), done. Writing objects: 100% (297/297), 6.35 MiB | 0 bytes/s, done. Total 297 (delta 22), reused 0 (delta 0) To git@172.16.194.130:/home/git/app.git * [new branch] master -&gt; master 4、Docker私有镜像仓库搭建1.创建私有仓库容器# 在node2上运行仓库容器 [root@k8s-node02 ~]# docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 --restart=always --name registry registry b45a684be68fbecebe6c433e38eb98ca805fe3b45e44594057cbb3c5bf99bb13 2.构建tale开源博客基础镜像mkdir tale &amp;&amp; cd tale cat &gt; Dockerfile&lt;&lt;EOF FROM centos:7 RUN yum install epel-release -y RUN yum install nginx supervisor -y &amp;&amp; yum clean all RUN sed -i &#39;47a proxy_pass http://127.0.0.1:9000;&#39; /etc/nginx/nginx.conf COPY supervisord.conf /etc/supervisord.conf ENV PATH /usr/local/jdk/bin/:$PATH WORKDIR /tale CMD [&quot;/usr/bin/supervisord&quot;] EOF cat &gt;supervisord.conf&lt;&lt;EOF [supervisord] nodaemon=true [program:tale] command=/usr/local/jdk/bin/java -jar /tale/tale-least.jar autostart=true autorestart=true [program:nginx] command=/usr/sbin/nginx -g &quot;daemon off;&quot; autostart=true autorestart=true EOF [root@k8s-node02 tale]# docker build -t tale:v1 . [root@k8s-node02 tale]# docker images|grep tale tale v1 cd96b2fd2d6b 41 seconds ago 372MB 3.提交tale基础镜像到私有仓库# 这一步尤为重要，因为后面Jenkins会来拉取这个镜像进行应用部署 docker tag tale:v1 172.16.194.130:5000/tale:v1 docker push 172.16.194.130:5000/tale:v1 # 查看提交的镜像版本信息 curl http://172.16.194.130:5000/v2/tale/tags/list 5、测试服务器安装Docker1.安装dockeryum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo yum install docker-ce 2.配置官方国内镜像源、添加私有仓库可信任[root@k8s-node02 ~]# cat &gt;/etc/docker/daemon.json &lt;&lt;EOF { &quot;registry-mirrors&quot;: [ &quot;https://registry.docker-cn.com&quot;] &quot;insecure-registries&quot;:[&quot;172.16.194.130:5000&quot;] } EOF [root@k8s-node01 ~]# systemctl restart docker 6、Jenkins安装1.编译镜像[root@k8s-node01 ~]# mkdir jenkins [root@k8s-node01~]# cd jenkins/ [root@k8s-node01 jenkins]# cat Dockerfile FROM jenkins USER root RUN echo &#39;&#39; &gt; /etc/apt/sources.list.d/jessie-backports.list &amp;&amp; \\wget http://mirrors.163.com/.help/sources.list.jessie -O /etc/apt/sources.list RUN apt-get update &amp;&amp; apt-get install -y git [root@k8s-node01 jenkins]# docker build -t jenkins:v1 . Sending build context to Docker daemon 2.048kB Step 1/4 : FROM jenkins ···中间略··· ---&gt; 8711202c6fda Successfully built 8711202c6fda Successfully tagged jenkins:v1 2.准备应用包在k8s-node01的宿主机上准备以下两个包，事先放在下面位置： /usr/local/apache-maven-3.5.0 /usr/local/jdk1.8.0_45 3. 运行Jenkins容器docker run -d \\ --name jenkins \\ -p 8080:8080 \\ -v /var/jenkins_home/:/var/jenkins_home \\ -v /usr/local/apache-maven-3.5.0:/usr/local/maven \\ -v /usr/local/jdk1.8.0_45:/usr/local/jdk \\ -v ~/.ssh:/root/.ssh \\ jenkins:v1 访问：http://172.16.194.129:8080/ 7、Jenkins基本配置 1.系统ssh连接配置点击：系统管理–&gt;系统管理（将页面拉到最后，配置ssh连接） 测试配置是否正常：Success，最后保存即可。 2.全局工具配置点击：系统管理–&gt; Global Tool Configuration 1.配置JDK环境2.git 默认即可3.配置maven 配置好了就保存。 8、Jenkins创建项目1.创建项目步骤新建–&gt;构建一个maven项目–&gt;点击ok 2.项目的一些配置2.1 配置git这里的git仓库配置，就是我们之前拉取的那个地址，分支指定master 2.2 构建触发器构建触发器，定制每小时出发一次，发现代码仓库有变化，就进行构建动作 2.3构建之前执行的动作# 如果多次构建的话，需要清空上次构建的环境 docker rm -f tale-test &amp;&amp; \\ docker image rm 172.16.194.130:5000/tale:base 2.3构建之后执行的动作# 构建好后，将环境使用docker运行到一个容器里，接下来就是测试啦！ docker run -itd \\ --name tale-test \\ -p 88:80 \\ -v /usr/local/jdk1.8.0_45:/usr/local/jdk \\ -v /data/tale:/tale \\ # 这个构建后的Command一定是能在服务器上手动执行成功的，在这里才能执行成功。 172.16.194.130:5000/tale:base 配置好后，应用–&gt;保存. 9、测试1、这是构建的结果# 第一次构建会比较慢，因为需要下载maven相关插件 Started by user nicksors [EnvInject] - Loading node environment variables. Building in workspace /var/jenkins_home/workspace/tale-test &gt; git rev-parse --is-inside-work-tree # timeout=10 ···中间略··· Digest: sha256:f82f2e175479d6d232efab45f81a4495cc4ad0a48135fd839dc27fdee8c13c77 Status: Downloaded newer image for 172.16.194.130:5000/tale:base ccc80d6215724027d9111069b5c8afa48c0b9df5694386656d611e19796b34b3 SSH: EXEC: completed after 21,474 ms SSH: Disconnecting configuration [172.16.194.129] ... SSH: Transferred 183 file(s) Finished: SUCCESS 2、查看构建的docker运行情况运行良好，访问：http://172.16.194.129:88/ [root@k8s-node01 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ccc80d621572 172.16.194.130:5000/tale:base &quot;/usr/bin/supervisord&quot; 11 minutes ago Up 11 minutes 0.0.0.0:88-&gt;80/tcp tale-test aa80a34ec7b6 jenkins:v1 &quot;/bin/tini -- /usr/l…&quot; 20 hours ago Up 4 hours 0.0.0.0:8080-&gt;8080/tcp, 50000/tcp jenkins [root@k8s-node01 ~]# 3、tale博客运行起来啦！第一次访问会让你设置一下站点信息设置账号密码：nicksors/abc123!! 博客页面： 后台： CI/CD：持续集成/持续部署 的集成环境搞定~！","tags":[{"name":"CI/CD","slug":"CI-CD","permalink":"//nicksors.cc/tags/CI-CD/"},{"name":"持续集成","slug":"持续集成","permalink":"//nicksors.cc/tags/持续集成/"}]},{"title":"使用Compose打包部署Docker项目","date":"2018-05-15T07:02:30.000Z","path":"2018/05/15/使用Compose打包部署Docker项目.html","text":"前言：Docker Compose 是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括服务构建，启动和停止。一些学习资料:Docker Compose 配置文件详解:https://www.jianshu.com/p/2217cfed29d7Docker Compose 项目：https://yeasy.gitbooks.io/docker_practice/content/compose/ 一、Compose简介Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。 Compose 恰好满足了这样的需求。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。 Compose 中有两个重要的概念： 服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。 项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。 Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。 二、安装与卸载官网：https://docs.docker.com/compose/install/ 二进制包： # sudo curl -L https://github.com/docker/compose/releases/download/1.20.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose # sudo chmod +x /usr/local/bin/docker-compose [root@k8s-node02 ~]# docker-compose --version docker-compose version 1.20.1, build 5d8c71b PIP安装： pip install -U docker-compose 卸载： 如果是二进制包方式安装的，删除二进制文件即可。 $ sudo rm /usr/local/bin/docker-compose 如果是通过 pip 安装的，则执行如下命令即可删除。 $ sudo pip uninstall docker-compose 三、使用首先介绍几个术语。 服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。 项目 (project)：由一组关联的应用容器组成的一个完整业务单元。 可见，一个项目可以由多个服务（容器）关联而成，Compose 面向项目进行管理。 案例一：构建web网站最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。 下面我们用 Python 来建立一个能够记录页面访问次数的 web 网站。 web应用 新建文件夹，在该目录中编写 app.py 文件 [root@k8s-node02 ~]# mkdir web_server [root@k8s-node02 ~]# cd web_server/ [root@k8s-node02 web_server]#vim app.py from flask import Flask from redis import Redis app = Flask(__name__) redis = Redis(host=&#39;redis&#39;, port=6379) @app.route(&#39;/&#39;) def hello(): count = redis.incr(&#39;hits&#39;) return &#39;Hello World! 该页面已被访问 {} 次。\\n&#39;.format(count) if __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, debug=True) Dockerfile 编写Dockerfile文件，内容为 [root@k8s-node02 web_server]# cat Dockerfile FROM python:3.6-alpine ADD . /code WORKDIR /code RUN pip install redis flask CMD [&quot;python&quot;, &quot;app.py&quot;] docker-compase.yml编写 docker-compose.yml 文件，这个是 Compose 使用的主模板文件。 [root@k8s-node02 web_server]# cat docker-compose.yml version: &#39;3&#39; services: web: build: . ports: - &quot;5000:5000&quot; redis: image: &quot;redis:alpine&quot; 运行 compose 项目 [root@k8s-node02 web_server]# docker-compose up Building web Step 1/5 : FROM python:3.6-alpine 3.6-alpine: Pulling from library/python 81033e7c1d6a: Already exists 9b61101706a6: Pull complete 35b21c1a8b97: Pull complete 4856f5aeeec4: Pull complete 84607ac623a4: Pull complete Digest: sha256:e10e26000b4dcfb66c52c11a6a7cc5251f6a95f9512fa9228bb3a66efc6c7075 Status: Downloaded newer image for python:3.6-alpine ---&gt; 4fcaf5fb5f2b Step 2/5 : ADD . /code ---&gt; 061db7e464f1 Step 3/5 : WORKDIR /code Removing intermediate container 7986a3cb8c7e ---&gt; 92a3ea98dfff Step 4/5 : RUN pip install redis flask ---&gt; Running in f0bed49a550d 此时访问本地 5000 端口，每次刷新页面，计数就会加 1。 注意事项 使用-d参数放入后台运行 docker-compose ps必须是在当前项目下执行，否则报错 [root@k8s-node02 web_server]# docker-compose up -d Starting webserver_redis_1 ... done Starting webserver_web_1 ... done [root@k8s-node02 web_server]# [root@k8s-node02 web_server]# docker-compose ps Name Command State Ports ----------------------------------------------------------------------------------- webserver_redis_1 docker-entrypoint.sh redis ... Up 6379/tcp webserver_web_1 python app.py Up 0.0.0.0:5000-&gt;5000/tcp [root@k8s-node02 web_server]# [root@k8s-node02 web_server]# cd [root@k8s-node02 ~]# docker-compose ps &lt;==找不到项目目录 ERROR: Can&#39;t find a suitable configuration file in this directory or any parent. Are you in the right directory? Supported filenames: docker-compose.yml, docker-compose.yaml [root@k8s-node02 ~]# 案例二：一键部署LNMP网站平台项目结构 [root@k8s-node02 compose_lnmp]# tree . ├── docker-compose.yml # lnmp项目的yaml文件，默认文件名：docker-compose.yml，可更改 ├── mysql # 数据库目录 │ ├── conf # 数据库配置目录 │ │ └── my.cnf # 数据库配置文件 │ └── data # 存储数据的目录（mysql的这些配置，是在容器起来所需要的东西） ├── nginx # Nginx目录 │ ├── Dockerfile # 会通过Dockerfile去构建Nginx │ ├── nginx-1.12.1.tar.gz │ └── nginx.conf ├── php # PHP目录 │ ├── Dockerfile # php 的Dockerfile文件 │ ├── php-5.6.31.tar.gz │ └── php.ini # 配置文件 └── wwwroot # 网站根目录 └── index.php 6 directories, 9 files docker-compose.yml [root@k8s-node02 compose_lnmp]# cat docker-compose.yml version: &#39;3&#39; # 版本，这里是指定compose的版本，compose有三个版本，分别为1、2、3； services: # 这里是一个顶级标签，这个是服务标签，下面定义了nginx、php、mysql等服务，当然今后你有多少个就写多少个。 nginx: # 具体服务名称 hostname: nginx # 服务的主机名 build: # 编译，同等于docker build Dockerfile ... context: ./nginx # 这里是指定Dockerfile的位置，这个位置是相对于docker-compose.yml所在位置而定的 dockerfile: Dockerfile # Dockerfile文件名称 ports: # 指定暴露的端口 - 81:80 networks: # 指定网络 - lnmp # 这里是具体的网络名称 volumes: # 映射的数据卷 - ./wwwroot:/usr/local/nginx/html php: hostname: php build: context: ./php dockerfile: Dockerfile networks: # 指定网络，要与Nginx、mysq同一个网络 - lnmp volumes: - ./wwwroot:/usr/local/nginx/html mysql: hostname: mysql image: mysql:5.6 # 要拉取的mysql容器镜像 ports: # 暴露的数据库端口 - 3306:3306 networks: # 指定到同一个网络 - lnmp volumes: # 映射数据卷 - ./mysql/conf:/etc/mysql/conf.d # ./mysql/conf是当前的目录，这里面有我们配置好的my.cnf配置文件 - ./mysql/data:/var/lib/mysql # ./mysql/data 这也是之前创建好的数据库data目录，用于存储mysql数据 command: --character-set-server=utf8 # 上面指定的mysql:5.6镜像在run的时候会接收到这个命令，并执行 environment: # 其他设置，这块属于数据库容器里的设置了，用户名、密码、要创建的数据库 MYSQL_ROOT_PASSWORD: 123456 MYSQL_DATABASE: wordpress MYSQL_USER: user MYSQL_PASSWORD: user123 networks: # 这里是一个顶级标签，创建网络（compose会先执行顶级标签，然后在执行后面的，这里的体现就是会先创建网络，再安装Nginx、php、mysql） lnmp: # 指定要创建的网络名称 nginx:Dockerfile [root@k8s-node02 compose_lnmp]# cat nginx/Dockerfile # 通过Dockerfile编译一个Nginx容器 FROM centos:7 # 选择一个基础镜像 MAINTAINER www.xxx.com # 作者名称 RUN yum install -y gcc gcc-c++ make openssl-devel pcre-devel # 初始安装包 ADD nginx-1.12.1.tar.gz /tmp # 将本地的Nginx软件添加到容器的/tmp目录下 RUN cd /tmp/nginx-1.12.1 &amp;&amp; \\ # 运行命令，解压和执行编译安装 ./configure --prefix=/usr/local/nginx &amp;&amp; \\ make -j 2 &amp;&amp; \\ make install RUN rm -rf /tmp/nginx-1.12.1* &amp;&amp; yum clean all # 清除一些不需要的东东 COPY nginx.conf /usr/local/nginx/conf # 然后再拷贝我们准备好的Nginx配置文件 WORKDIR /usr/local/nginx # 设置工作目录 EXPOSE 80 # 开放80端口，注意这里是开放，是运行这个容器时会打开80端口，不是对外暴露端口 CMD [&quot;./sbin/nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;] #运行容器时所需要执行的命令 php:Dockerfile # 上面说过的选项，这里就不在赘述了哈！ [root@k8s-node02 compose_lnmp]# cat php/Dockerfile FROM centos:7 MAINTAINER www.xxx.com RUN yum install -y gcc gcc-c++ make gd-devel libxml2-devel libcurl-devel libjpeg-devel libpng-devel openssl-devel ADD php-5.6.31.tar.gz /tmp/ RUN cd /tmp/php-5.6.31 &amp;&amp; \\ ./configure --prefix=/usr/local/php \\ --with-config-file-path=/usr/local/php/etc \\ --with-mysql --with-mysqli \\ --with-openssl --with-zlib --with-curl --with-gd \\ --with-jpeg-dir --with-png-dir --with-iconv \\ --enable-fpm --enable-zip --enable-mbstring &amp;&amp; \\ make -j 4 &amp;&amp; \\ make install &amp;&amp; \\ cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf &amp;&amp; \\ sed -i &quot;s/127.0.0.1/0.0.0.0/&quot; /usr/local/php/etc/php-fpm.conf &amp;&amp; \\ sed -i &quot;21a \\daemonize = no&quot; /usr/local/php/etc/php-fpm.conf COPY php.ini /usr/local/php/etc RUN rm -rf /tmp/php-5.6.31* &amp;&amp; yum clean all WORKDIR /usr/local/php EXPOSE 9000 CMD [&quot;./sbin/php-fpm&quot;, &quot;-c&quot;, &quot;/usr/local/php/etc/php-fpm.conf&quot;] 一键部署 [root@k8s-node02 compose_lnmp]# docker-compose up -d ···一个漫长的编译、安装、拉取镜像过程··· [root@k8s-node02 compose_lnmp]# docker-compose ps Name Command State Ports ------------------------------------------------------------------------------------- composelnmp_mysql_1 docker-entrypoint.sh --cha ... Up 0.0.0.0:3306-&gt;3306/tcp composelnmp_nginx_1 ./sbin/nginx -g daemon off; Up 0.0.0.0:81-&gt;80/tcp composelnmp_php_1 ./sbin/php-fpm -c /usr/loc ... Up 9000/tcp 将WordPress下载到站点解压并安装，最终运行结果如下： 四、应用场景 互联网产品交付客户 将产品封装成docker compose文件项目文件，打包交付给客户；省却手动部署环境的麻烦，高效精简整个交付过程。 特制的环境应用 比如咱们经常部署的lnmp环境，那这种环境不希望重复部署，就可以编写好yaml文件，通过compase 来管理整个环境。","tags":[{"name":"Compose","slug":"Compose","permalink":"//nicksors.cc/tags/Compose/"}]},{"title":"使用cAdvisor+InfluxDB+Grafana构建容器监控系统","date":"2018-05-14T07:08:37.000Z","path":"2018/05/14/使用cAdvisor+InfluxDB+Grafana构建容器监控系统.html","text":"概述： cadvisor：数据采集 Influxdb：数据存储 grafana：数据展示 三个都直接下载镜像启动容器即可。 一、启动三个应用容器# 先创建一个专属于他们几个小基友的网络 docker network create monitor #InfluxDB docker run -d \\ --name=influxdb \\ --net monitor \\ -p 8083:8083 \\ -p 8086:8086 \\ tutum/influxdb # cAdvisor docker run -d \\ --name=cadvisor \\ --net monitor \\ -p 8081:8080 \\ --mount type=bind,src=/,dst=/rootfs,ro \\ --mount type=bind,src=/var/run,dst=/var/run \\ --mount type=bind,src=/sys,dst=/sys,ro \\ --mount type=bind,src=/var/lib/docker,dst=/var/lib/docker,ro \\ google/cadvisor \\ -storage_driver=influxdb \\ -storage_driver_db=cadvisor \\ -storage_driver_host=influxdb:8086 #Grafana docker run -d \\ --name=grafana \\ --net monitor \\ -p 3000:3000 \\ grafana/grafana # 如果想让容器异常退出后重启，你需要加上下面的参数 --restart=always 二、各个应用访问界面Grafana： http://172.16.194.130:3000/login 用户名和密码默认：admin InfluxDB： http://172.16.194.130:8083/ cAdvisor：http://172.16.194.130:8081/ 三、配置3.1、在influxdb里创建数据库，用于cadvisor存储数据CREATE DATABASE “cadvisor” 3.2、influxdb里创建一个用户，用于grafana连接influxdb数据库CREATE USER “grafana” WITH PASSWORD ‘grafana’ 3.3、grafana添加数据源 登录grafana –&gt;点击Add data source Type：选择influxdbURL：influxdb （monitor 网络互连，所以直接使用name名称即可）database: cadvisor 上面创建好的，账号密码也是填写之前创建好的 3.4、grafana创建Dashboard 添加过程及细节，自己研究，这里不做输出 最终添加的结果，这里只是添加了两个示例 那么，“容器监控系统” 解决方案在这里就结束了，期待更多的玩法ing.","tags":[{"name":"cAdvisor","slug":"cAdvisor","permalink":"//nicksors.cc/tags/cAdvisor/"},{"name":"InfluxDB","slug":"InfluxDB","permalink":"//nicksors.cc/tags/InfluxDB/"},{"name":"Grafana","slug":"Grafana","permalink":"//nicksors.cc/tags/Grafana/"}]},{"title":"Docker图形界面管理Portainer","date":"2018-05-14T06:48:38.000Z","path":"2018/05/14/Docker图形界面管理Portainer.html","text":"官网：https://portainer.io/ 一、创建卷docker volume create portainer_data 二、创建portainer容器 (默认可以自动创建卷)# docker run -d \\ --name portainer \\ -p 9000:9000 \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v portainer_data:/data \\ portainer/portainer 三、配置portainerhttp://172.16.194.130:9000/ 用户名默认：admin需要设置密码，输入：abc123!! 选择本地或远程连接，我这里选择本地，点击Connect 这是整个管理页面的全貌，自己研究玩吧~","tags":[{"name":"portainer","slug":"portainer","permalink":"//nicksors.cc/tags/portainer/"}]},{"title":"搭建Hexo博客所用到的技术","date":"2018-05-10T08:43:55.000Z","path":"2018/05/10/搭建Hexo所用到的技术.html","text":"前言：这里记录着我搭建博客时用到了以下技术，基本上是参考各位博友写的博文。为了防止哪天我的博客崩掉后，我还能想起来如何重建它。 Mac上hexo博客的搭建 hexo使用yilia主题 Gitment：使用 GitHub Issues 搭建评论系统 添加gitment评论系统 添加Gitment评论系统踩过的坑（这些坑我全部踩了一遍…） 遇到的坑：点击login会url链接报错 hexo yilia主题添加文章访问量统计 百度、谷歌统计配置 网站访问量显示 Hexo七牛插件安装与使用 以上，非常感谢各位博友的辛苦总结.","tags":[{"name":"Heox","slug":"Heox","permalink":"//nicksors.cc/tags/Heox/"}]},{"title":"Docker企业级私有仓库方案(harbor)","date":"2018-05-10T06:37:16.000Z","path":"2018/05/10/Docker企业级私有仓库方案(harbor).html","text":"前言： Docker Hub作为Docker默认官方公共镜像，如果自己想搭建私有镜像仓库，官网也提供registry镜像，使得搭建私有仓库非常简单。 一、搭建私有镜像仓库:registry1.1、下载registry镜像并启动 $ docker pull registry $ docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 --restart=always --name registry registry 1.2、测试，查看镜像仓库中所有镜像 [root@k8s-node02 ~]# curl http://127.0.0.1:5000/v2/_catalog {&quot;repositories&quot;:[]} 1.3、私有镜像仓库管理1）配置私有仓库可信任 $ vim /etc/docker/daemon.json {&quot;insecure-registries&quot;:[&quot;127.0.0.1:5000&quot;]} systemctl restart docker 这里需要注意一点，如果daemon.json里已经有配置，&quot;需要在原有配置后面加逗号，不然失效&quot; 譬如： [root@k8s-node02 ~]# cat /etc/docker/daemon.json { &quot;registry-mirrors&quot;: [ &quot;https://registry.docker-cn.com&quot;], &quot;insecure-registries&quot;: [&quot;172.16.194.130:5000&quot;] } 2）打标签 $ docker tag centos:6 127.0.0.1:5000/centos:7 3）上传 $ docker push 127.0.0.1:5000/centos:7 4）下载 $ docker pull 127.0.0.1:5000/centos:7 5）列出镜像标签 [root@k8s-node02 ~]# curl http://127.0.0.1:5000/v2/centos/tags/list {&quot;name&quot;:&quot;centos&quot;,&quot;tags&quot;:[&quot;7&quot;]} 注意：127.0.0.1可以换成你网卡的地址 二、Docker Hub公共镜像仓库使用因为dockerHub是国外的服务器，push和pull操作都比较慢，甚至有连接超时的情况，个人研究玩玩还是可以的。https://cloud.docker.com/swarm/nicksors 1）注册帐号https://hub.docker.com 2）登录Docker Hub $ docker login 或 [root@k8s-node02 ~]# docker login --username=nicksors --password=与GitHub密码一样 WARNING! Using --password via the CLI is insecure. Use --password-stdin. Login Succeeded 3）镜像打标签 $ docker tag nginx:1.12 nicksors/nginx:v2 4）上传 $ docker push nicksors/nginx:v2 5）下载 $ docker pull nicksors/nginx:v2 三、基于Harbor搭建Docker私有镜像仓库（推荐:很多企业都用这个）3.1、什么是Harbor？Harbor是VMware开源的又一个Docker Registry企业级私有仓库，其项目地址为https://github.com/vmware/harbor；相比Docker公司自己提供的Registry私有镜像仓库而言，Harbor提供了更多的功能，如下： 基于角色的访问控制 - 用户与Docker镜像仓库通过“项目”进行组织管理，一个用户可以对多个镜像仓库在同一命名空间（project）里有不同的权限。 镜像复制 - 镜像可以在多个Registry实例中复制（同步）。尤其适合于负载均衡，高可用，混合云和多云的场景。 图形化用户界面 - 用户可以通过浏览器来浏览，检索当前Docker镜像仓库，管理项目和命名空间。 AD/LDAP 支持 - Harbor可以集成企业内部已有的AD/LDAP，用于鉴权认证管理。 审计管理 - 所有针对镜像仓库的操作都可以被记录追溯，用于审计管理。 国际化 - 已拥有英文、中文、德文、日文和俄文的本地化版本。更多的语言将会添加进来。 RESTful API - RESTful API 提供给管理员对于Harbor更多的操控, 使得与其它管理软件集成变得更容易。 部署简单 - 提供在线和离线两种安装工具， 也可以安装到vSphere平台(OVA方式)虚拟设备。 以上来自官网介绍：https://vmware.github.io/harbor/cn/ 3.2、准备环境 自己创建的虚拟机：CentOS7.2、配置是2G2C； Docker版本：Docker version 18.03.0-ce Docker-compose：docker-compose version 1.20.1 Harbor版本：harbor-offline-installer-v1.4.0.tgz 3.3、安装Harbor在安装Harbor之前，必须保证你的环境已经安装好docker和docker-compose了,这两个安装方法在Docker官网都有： 安装Docker方法：https://docs.docker.com/install/linux/docker-ce/centos 安装Docker-Compose方法：https://docs.docker.com/compose/install/#install-compose 你可以在 Harbor版本https://github.com/vmware/harbor/releases 地址下载你想要装的版本，这里我选择最新的1.4.0，当然你看到的时候已经不是最新版本了。 # 选择离线安装版本 $ wget https://storage.googleapis.com/harbor-releases/release-1.4.0/harbor-offline-installer-v1.4.0.tgz （如果下载慢的话，你可以使用迅雷下载，有的网友就这么干，会快很多） 解压下载的包，进入解压后的harbor目录，里面有个harbor.cfg就是配置文件啦，简单说下：这里面可以配置LDAP，数据库，邮件信息，ssl证书等。 $ vim harbor.cfg # 我配置了两个地方，主机名和Harbor admin的密码，其他默认 hostname = 172.16.194.130 harbor_admin_password = abc123!! 下面奉上一份harbor.cfg的关键参数说明： ## Configuration file of Harbor #hostname设置访问地址，可以使用ip、域名，不可以设置为127.0.0.1或localhost hostname = 172.16.194.130 #这里我使用本机IP # 访问协议，默认是http，也可以设置https，如果设置https，则nginx ssl需要设置on ui_url_protocol = http #Maximum number of job workers in job service max_job_workers = 3 #Determine whether or not to generate certificate for the registry&#39;s token. #If the value is on, the prepare script creates new root cert and private key #for generating token to access the registry. If the value is off the default key/cert will be used. #This flag also controls the creation of the notary signer&#39;s cert. customize_crt = on # 指定的证书文件，生产环境一定要使用ssl证书 ssl_cert = /data/cert/server.crt ssl_cert_key = /data/cert/server.key # 存放证书的路径,这个路径会挂载到宿主机的/data/目录下 secretkey_path = /data #Admiral&#39;s url, comment this attribute, or set its value to NA when Harbor is standalone admiral_url = NA #Log files are rotated log_rotate_count times before being removed. If count is 0, old versions are removed rather than rotated. log_rotate_count = 50 #Log files are rotated only if they grow bigger than log_rotate_size bytes. If size is followed by k, the size is assumed to be in kilobytes. #If the M is used, the size is in megabytes, and if G is used, the size is in gigabytes. So size 100, size 100k, size 100M and size 100G #are all valid. log_rotate_size = 200M #************************BEGIN INITIAL PROPERTIES************************ # 配置邮件server信息 email_identity = email_server = smtp.mydomain.com email_server_port = 25 email_username = sample_admin@mydomain.com email_password = abc email_from = admin &lt;sample_admin@mydomain.com&gt; email_ssl = false email_insecure = false # 启动Harbor后，管理员UI登录的密码，默认是Harbor12345 harbor_admin_password = abc123!! # 认证方式，这里支持多种认证方式，如LADP、本次存储、数据库认证。默认是db_auth，mysql数据库认证 auth_mode = db_auth # ldap配置 ldap_url = ldaps://ldap.mydomain.com #A user&#39;s DN who has the permission to search the LDAP/AD server. #If your LDAP/AD server does not support anonymous search, you should configure this DN and ldap_search_pwd. #ldap_searchdn = uid=searchuser,ou=people,dc=mydomain,dc=com #the password of the ldap_searchdn #ldap_search_pwd = password #The base DN from which to look up a user in LDAP/AD ldap_basedn = ou=people,dc=mydomain,dc=com #Search filter for LDAP/AD, make sure the syntax of the filter is correct. #ldap_filter = (objectClass=person) # The attribute used in a search to match a user, it could be uid, cn, email, sAMAccountName or other attributes depending on your LDAP/AD ldap_uid = uid #the scope to search for users, 0-LDAP_SCOPE_BASE, 1-LDAP_SCOPE_ONELEVEL, 2-LDAP_SCOPE_SUBTREE ldap_scope = 2 #Timeout (in seconds) when connecting to an LDAP Server. The default value (and most reasonable) is 5 seconds. ldap_timeout = 5 #Verify certificate from LDAP server ldap_verify_cert = true #Turn on or off the self-registration feature self_registration = on #The expiration time (in minute) of token created by token service, default is 30 minutes token_expiration = 30 # 用户创建项目权限控制，默认是everyone（所有人），也可以设置为adminonly（只能管理员） project_creation_restriction = everyone #************************END INITIAL PROPERTIES************************ #######Harbor DB configuration section####### #The address of the Harbor database. Only need to change when using external db. db_host = mysql #The password for the root user of Harbor DB. Change this before any production use. db_password = root123 #The port of Harbor database host db_port = 3306 #The user name of Harbor database db_user = root ##### End of Harbor DB configuration####### #The redis server address. Only needed in HA installation. redis_url = ##########Clair DB configuration############ #Clair DB host address. Only change it when using an exteral DB. clair_db_host = postgres #The password of the Clair&#39;s postgres database. Only effective when Harbor is deployed with Clair. #Please update it before deployment. Subsequent update will cause Clair&#39;s API server and Harbor unable to access Clair&#39;s database. clair_db_password = password #Clair DB connect port clair_db_port = 5432 #Clair DB username clair_db_username = postgres #Clair default database clair_db = postgres ##########End of Clair DB configuration############ #The following attributes only need to be set when auth mode is uaa_auth uaa_endpoint = uaa.mydomain.org uaa_clientid = id uaa_clientsecret = secret uaa_verify_cert = true uaa_ca_cert = /path/to/ca.pem ### Docker Registry setting ### #registry_storage_provider can be: filesystem, s3, gcs, azure, etc. registry_storage_provider_name = filesystem #registry_storage_provider_config is a comma separated &quot;key: value&quot; pairs, e.g. &quot;key1: value, key2: value2&quot;. #Refer to https://docs.docker.com/registry/configuration/#storage for all available configuration. registry_storage_provider_config = 3.4、启动Harbor修改完配置文件后，在的当前目录执行./install.sh，Harbor服务就会根据当期目录下的docker-compose.yml开始下载依赖的镜像，检测并按照顺序依次启动各个服务。 $ ./install.sh [Step 0]: checking installation environment ... Note: docker version: 18.03.0 Note: docker-compose version: 1.20.1 [Step 1]: loading Harbor images ... Loaded image: vmware/notary-server-photon:v0.5.1-v1.4.0 Loaded image: vmware/notary-signer-photon:v0.5.1-v1.4.0 Loaded image: vmware/harbor-db:v1.4.0 Loaded image: vmware/clair-photon:v2.0.1-v1.4.0 Loaded image: vmware/postgresql-photon:v1.4.0 Loaded image: vmware/harbor-adminserver:v1.4.0 Loaded image: vmware/harbor-ui:v1.4.0 Loaded image: vmware/harbor-log:v1.4.0 Loaded image: vmware/harbor-jobservice:v1.4.0 Loaded image: vmware/nginx-photon:v1.4.0 Loaded image: vmware/registry-photon:v2.6.2-v1.4.0 Loaded image: vmware/photon:1.0 Loaded image: vmware/mariadb-photon:v1.4.0 Loaded image: vmware/harbor-db-migrator:1.4 [Step 2]: preparing environment ... Clearing the configuration file: ./common/config/adminserver/env Clearing the configuration file: ./common/config/ui/env Clearing the configuration file: ./common/config/ui/app.conf Clearing the configuration file: ./common/config/ui/private_key.pem Clearing the configuration file: ./common/config/db/env Clearing the configuration file: ./common/config/jobservice/env Clearing the configuration file: ./common/config/jobservice/app.conf Clearing the configuration file: ./common/config/registry/config.yml Clearing the configuration file: ./common/config/registry/root.crt Clearing the configuration file: ./common/config/nginx/nginx.conf Clearing the configuration file: ./common/config/log/logrotate.conf loaded secret from file: /data/secretkey Generated configuration file: ./common/config/nginx/nginx.conf Generated configuration file: ./common/config/adminserver/env Generated configuration file: ./common/config/ui/env Generated configuration file: ./common/config/registry/config.yml Generated configuration file: ./common/config/db/env Generated configuration file: ./common/config/jobservice/env Generated configuration file: ./common/config/log/logrotate.conf Generated configuration file: ./common/config/jobservice/app.conf Generated configuration file: ./common/config/ui/app.conf Generated certificate, key file: ./common/config/ui/private_key.pem, cert file: ./common/config/registry/root.crt The configuration files are ready, please use docker-compose to start the service. [Step 3]: checking existing instance of Harbor ... [Step 4]: starting Harbor ... Creating harbor-log ... done Creating harbor-db ... done Creating registry ... done Creating harbor-adminserver ... done Creating harbor-ui ... done Creating nginx ... done Creating harbor-jobservice ... done ✔ ----Harbor has been installed and started successfully.---- Now you should be able to visit the admin portal at http://172.16.194.130. For more details, please visit https://github.com/vmware/harbor . # 这时候你可以通过docker-compose 或docker ps来查看Harbor依赖运行的一些容器 # 当然你也可以通过docker-compose来管理这些容器 [root@k8s-node02 harbor]# docker-compose ps Name Command State Ports ------------------------------------------------------------------------------------------------------------------------------------- harbor-adminserver /harbor/start.sh Up (healthy) harbor-db /usr/local/bin/docker-entr ... Up (healthy) 3306/tcp harbor-jobservice /harbor/start.sh Up (healthy) harbor-log /bin/sh -c /usr/local/bin/ ... Up (healthy) 127.0.0.1:1514-&gt;10514/tcp harbor-ui /harbor/start.sh Up (healthy) nginx nginx -g daemon off; Up 0.0.0.0:443-&gt;443/tcp, 0.0.0.0:4443-&gt;4443/tcp, 0.0.0.0:80-&gt;80/tcp registry /entrypoint.sh serve /etc/ ... Up (healthy) 5000/tcp [root@k8s-node02 harbor]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES baf9d3e586f8 vmware/harbor-jobservice:v1.4.0 &quot;/harbor/start.sh&quot; About an hour ago Up About an hour (healthy) harbor-jobservice 484d5c4fca4b vmware/nginx-photon:v1.4.0 &quot;nginx -g &#39;daemon of…&quot; About an hour ago Up About an hour 0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp, 0.0.0.0:4443-&gt;4443/tcp nginx dd7c62b45af1 vmware/harbor-ui:v1.4.0 &quot;/harbor/start.sh&quot; About an hour ago Up About an hour (healthy) harbor-ui e5494bd12f64 vmware/registry-photon:v2.6.2-v1.4.0 &quot;/entrypoint.sh serv…&quot; About an hour ago Up About an hour (healthy) 5000/tcp registry 915b753623b7 vmware/harbor-adminserver:v1.4.0 &quot;/harbor/start.sh&quot; About an hour ago Up About an hour (healthy) harbor-adminserver 55ca16b86243 vmware/harbor-db:v1.4.0 &quot;/usr/local/bin/dock…&quot; About an hour ago Up About an hour (healthy) 3306/tcp harbor-db 30ca0cb76dd0 vmware/harbor-log:v1.4.0 &quot;/bin/sh -c /usr/loc…&quot; About an hour ago Up About an hour (healthy) 127.0.0.1:1514-&gt;10514/tcp 3.5、登录Harbor启动完成后，会提示你Harbor的访问地址：http://172.16.194.130 登录界面 输入账号和我们预先设定的密码：admin/abc123!! 我们可以看到系统各个模块如下： 项目：新增/删除项目，查看镜像仓库，给项目添加成员、查看操作日志、复制项目等 日志：仓库各个镜像create、push、pull等操作日志 系统管理 用户管理：新增/删除用户、设置管理员等 复制管理：新增/删除从库目标、新建/删除/启停复制规则等 配置管理：认证模式、复制、邮箱设置、系统设置等 其他设置 用户设置：修改用户名、邮箱、名称信息 修改密码：修改用户密码 注意：非系统管理员用户登录，只能看到有权限的项目和日志，其他模块不可见。 3.6、向Harbor仓库中心提交私有镜像我们要尝试下能不能把自己 Docker 里面的镜像 push 到 Harbor 的 library 里来（默认这个 library 项目是公开的，所有人都可以有读的权限，都不需要 docker login 进来，就可以拉取里面的镜像）。 3.6.1、配置Docker registry仓库地址在/etc/docker/daemon.json里添加配置如下： { &quot;insecure-registries&quot;: [&quot;172.16.194.130&quot;] } 配置好后，别忘了重启systemctl restart docker 3.6.2、Docker 登录Harbor为什么要登录呢？跟Docker Hub一样，你得登录才能表明你是合法用户，才能push； $ docker login 172.16.194.130 Username: admin Password: (这里输入harbor平台设置的admin密码) Login Succeeded 3.6.3、本地私有镜像打tag，提交到Harbor$ docker tag tale:base 172.16.194.130/library/tale:base $ docker push 172.16.194.130/library/tale The push refers to repository [172.16.194.130/library/tale] a3ece4722ead: Pushed ed61150eb02c: Pushed 0f9f3d37a459: Pushed 8ed018b01f91: Pushed b17185091796: Pushed b03095563b79: Pushed base: digest: sha256:f82f2e175479d6d232efab45f81a4495cc4ad0a48135fd839dc27fdee8c13c77 size: 1574 提交成功，我们来看看Harbor仓库里的信息 能看到已经提交到libary公共仓库中。 同理，你也可以测试下从 Harbor pull 镜像到你的 Docker 中去，操作如下： $ docker rmi 172.16.194.130/library/tale:base $ docker pull 172.16.194.130/library/tale:base base: Pulling from library/tale Digest: sha256:f82f2e175479d6d232efab45f81a4495cc4ad0a48135fd839dc27fdee8c13c77 Status: Downloaded newer image for 172.16.194.130/library/tale:base [root@k8s-node02 harbor]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE 172.16.194.130/library/tale base ab8e3ca33cd0 5 days ago 372MB 镜像在被我删除后，从Harbor里成功pull了回来。 3.7、Harbor配置ssl认证3.7.1、创建证书$ cd /data/cert/ 1、创建 CA 根证书 $ openssl req -newkey rsa:4096 -nodes -sha256 -keyout ca.key -x509 -days 365 -out ca.crt -subj &quot;/C=CN/L=xian/O=nova/CN=harbor-registry&quot; 2、生成一个证书签名, 设置访问域名为harbor.moxiu.cn $ openssl req -newkey rsa:4096 -nodes -sha256 -keyout harbor.moxiu.cn.key -out server.csr -subj &quot;/C=CN/L=xian/O=nova/CN=harbor.moxiu.cn&quot; 3、生成主机的证书 $ openssl x509 -req -days 365 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out harbor.moxiu.cn.crt 3.7.2、配置harbor以https方式访问$ vim harbor.cfg hostname = harbor.moxiu.cn:443 ui_url_protocol = https ssl_cert = /data/cert/harbor.moxiu.cn.crt ssl_cert_key = /data/cert/harbor.moxiu.cn.key 3.7.3、配置Docker registry仓库地址在/etc/docker/daemon.json里添加配置如下： { &quot;insecure-registries&quot;: [&quot;harbor.moxiu.cn&quot;] } 然后，重启docker服务生效 3.7.4、登录验证1、验证admin登录方法1 $ docker login harbor.moxiu.cn Username (admin): admin Password: Login Succeeded 2、验证admin登录方法2 $ docker login -u admin -p abc123!! harbor.moxiu.cn Login Succeeded 3、Web页面登录验证http://harbor.moxiu.cn/harbor/sign-in用户名/密码：admin/abc123!! 因为不是有效机构颁发的证书，所有浏览器会提示不安全。如果企业需要使用，那需要买商用的证书更换即可。","tags":[{"name":"harbor","slug":"harbor","permalink":"//nicksors.cc/tags/harbor/"}]}]